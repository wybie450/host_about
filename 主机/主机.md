==主机==

​							------26届王文君

- **什么是unix？**

  | **定义**     | Unix 是一种**多用户、多任务、分时操作系统**，诞生于 1969 年，是现代操作系统的重要基石 |
  | ------------ | ------------------------------------------------------------ |
  | **特点**     | 支持多用户、多任务、命令行强大、文件系统统一、工具链丰富、设计哲学优秀 |
  | **代表系统** | 原始 Unix → System V / BSD，现代类 Unix 系统包括 **Linux、macOS、Android（底层）、FreeBSD 等** |
  | **设计哲学** | “做一件事并做好”、一切皆文件、组合小工具完成复杂任务         |
  | **影响**     | 是现代计算机科学、服务器、嵌入式、云计算、移动 OS 的重要基础 |

- **LINUX**

  一个典型的嵌入式 Linux 主机系统

  ```
  +-----------------------------+
  |         应用程序            |  <-- 网络编程、GPIO 控制、业务逻辑
  +-----------------------------+
  |        系统服务 / Shell     |
  +-----------------------------+
  |     C 库 / 中间件（如 BusyBox）|
  +-----------------------------+
  |         Linux 内核          |  <-- 驱动、进程管理、内存、文件系统
  +-----------------------------+
  |       Bootloader（U-Boot）  |  <-- 启动引导，加载内核
  +-----------------------------+
  |         Flash / eMMC        |  <-- 存放 bootloader、内核、文件系统
  +-----------------------------+
  |           硬件（CPU、GPIO等）     |
  +-----------------------------+
  ```

   **引导启动 → 内核运行 → 文件系统挂载 → 驱动使用 → 应用开发（GPIO/I2C/SPI/串口/网络）**

# 概念

- 工控机类别：

工控机的主要类别有：IPC（PC总线工业电脑）、[PLC](https://zhida.zhihu.com/search?content_id=108908745&content_type=Article&match_order=1&q=PLC&zhida_source=entity)（可编程控制系统）、[DCS](https://zhida.zhihu.com/search?content_id=108908745&content_type=Article&match_order=1&q=DCS&zhida_source=entity)（分散型控制系统）、[FCS](https://zhida.zhihu.com/search?content_id=108908745&content_type=Article&match_order=1&q=FCS&zhida_source=entity)（现场总线系统）及CNC（数控系统）五种。

<img src="https://pic2.zhimg.com/v2-59145dae4905f6ab906aaa58bbc19b13_1440w.jpg" alt="img" style="zoom: 67%;" />

- arm和x86架构：

  X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。

  　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.而且其功耗远远低于x86

- 安装包格式：

![image-20250718221816138](主机.assets/image-20250718221816138.png)

## 树莓派

pi 4B + TF卡 + 电源适配器 + 读卡器 + HDMI接口屏幕 + micro HDMI转HDMI数据线

<img src="/home/wybie/.config/Typora/typora-user-images/image-20250718194808440.png" alt="image-20250718194808440" style="zoom:67%;" />

- 烧录：树莓派程序刻录在tf卡上

  注意！树莓派4b及以上版本tf卡需要u3及以上的写入速度

1. ![image-20250718194916350](/home/wybie/.config/Typora/typora-user-images/image-20250718194916350.png)

2. ![image-20250718195044814](/home/wybie/.config/Typora/typora-user-images/image-20250718195044814.png)

3. ![image-20250722095246021](主机.assets/image-20250722095246021.png)

   网络连接

   - sd卡取消可视化，写入.conf文件

     ```
     country=CN
     ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
     update_config=1
     network={
         ssid="无线网名字"
         psk="密码"
         priority=10
     }
     ```

- 查看板载gpio代码：

  `pinout`

- 输入程序代码：

  `gpio readall`

  <img src="主机.assets/image-20250722171651835.png" alt="image-20250722171651835" style="zoom:50%;" />

- 用Python控制：

  <img src="主机.assets/image-20250722172159566.png" alt="image-20250722172159566" style="zoom:50%;" />

![image-20250722172338087](主机.assets/image-20250722172338087.png)

<img src="主机.assets/image-20250722172407471.png" alt="image-20250722172407471" style="zoom:50%;" />

- 命令行：

  ![image-20250722172455844](主机.assets/image-20250722172455844.png)

#### ==磁盘烧录方法(命令行)==

但系统烧录官方工具并不好用，最好自己去官网下载镜像文件后磁盘烧录，很多网上的资料层次不齐，这里是流程和一些简单的问题解决。有一点很重要，移除磁盘的时候一定要把挂载点都去除了再拔掉。

- 文件读取失败：

  大抵原理是磁盘下好后，bootloader进行一种自查程序，重新读取前面的内存块，资料很多会让你检查sd卡的损坏或者坏块，其实大概率原因可能是进行了热拔插或是源文件出错或格式化出问题等，导致资料与预下载的不一致，应自纠一下流程，而不是第一时间去查sd卡的错误

- fat格式无法正确读取：

  ```
  wybie@wenjun:~$ dosfsck -w -r -l -v -t /dev/sda1
  ```

  发现是下载的fat格式和备份的fat格式不一样，连续点1让它自动修复

  如果你之后要将该设备安全卸载，使用：

  ```
  sudo umount /dev/sda1
  sudo umount /dev/sda2或
  udisksctl power-off -b /dev/sda
  ```

​	不然可能因为热拔插导致数据损坏或磁盘物理损坏

- 磁盘烧录正确流程

```
1. sudo umount /dev/sda1
sudo umount /dev/sda2
2.lsble #确保没有挂载点
3.sudo dd if=<文件地址> of=/dev/sda bs=4M status=progress conv=fsync
4.sync
```

#### ==磁盘写保护关闭==

有时系统因为错误或手动挂载为只读：

```
mount | grep sdb1   # 假设你的盘是 /dev/sdb1
```

如果显示 `ro` 就是只读挂载。
 重新挂载为读写：

```
sudo mount -o remount,rw /dev/sdb1 /挂载点路径
```



安装工具：

```
sudo apt install hdparm
```

查看写保护状态：

```
sudo hdparm -r /dev/sdb
```

返回示例：

```
/dev/sdb:
 readonly = 1 (on)
```

关闭写保护：

```
sudo hdparm -r0 /dev/sdb
```

### 相机：

```
sudo pip3 install zmq
sudo pip3 install pybase64
```

```
import cv2
import zmq
import base64
 
 
def main():
    '''
    主函数
    '''
    IP = '192.168.2.148' #上位机视频接受端的IP地址
 
    # 创建并设置视频捕获对象
    cap = cv2.VideoCapture(0)
    print("摄像头是否已经打开 ？ {}".format(cap.isOpened()))
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)  # 设置图像宽度
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)  # 设置图像高度
 
    # 建立TCP通信协议
    contest = zmq.Context()
    footage_socket = contest.socket(zmq.PAIR)
    footage_socket.connect('tcp://%s:5555'%IP)
 
    while True:
        # 读取图像
        ret, frame = cap.read()
 
        # 转换为流数据并编码
        encoded, buffer = cv2.imencode('.jpg', frame) 
        jpg_as_test = base64.b64encode(buffer) #把内存中的图像流数据进行base64编码
 
        # 发送数据
        footage_socket.send(jpg_as_test) #把编码后的流数据发送给视频的接收端
        cv2.waitKey(5) #延时等待，防止出现窗口无响应
 
 
if __name__ == '__main__':
    '''
    程序入口
    '''
    main()
```

### 串口：

![image-20250726094923024](主机.assets/image-20250726094923024.png)

```
#!/usr/bin/python
# -*- coding:utf-8 -*-
import serial

#ser = serial.Serial("/dev/ttyAMA0",115200)
ser = serial.Serial("/dev/ttyS0",115200)

print("serial test start ...")
ser.write("Hello Wrold !!!\n")
try:
    while True:
        ser.write(ser.read())
except KeyboardInterrupt:
    if ser != None:
        ser.close()
```

<img src="主机.assets/树莓派4b引脚复用.jpg" alt="树莓派4b引脚复用" style="zoom:50%;" />

- zmq_subsceiber.c

  ```
  #include "zmq_subscriber.h"
  #include <serial/serial.h>
  
  int main() {
      // 打开串口（如 /dev/ttyUSB0）
      serial::Serial ser("/dev/ttyUSB0", 115200, serial::Timeout::simpleTimeout(1000));
      if (!ser.isOpen()) {
          std::cerr << "Failed to open serial port!" << std::endl;
          return -1;
      }
  
      // 创建 ZMQ 订阅端
      ZMQSubscriber subscriber("tcp://localhost:5556", ser);
  
      // 循环接收并转发标志位
      subscriber.run();
  
      return 0;
  }
  ```

- zmq_subscriber.h

  ```
  #pragma once
  #include <zmq.hpp>
  #include <string>
  #include <serial/serial.h> // 需要安装 libserial-dev
  
  class ZMQSubscriber {
  public:
      ZMQSubscriber(const std::string& endpoint, serial::Serial& serial_port);
      void run(); // 循环接收标志位并转发到串口
  
  private:
      zmq::context_t context_;
      zmq::socket_t socket_;
      serial::Serial& serial_port_; // 引用外部的串口对象
  };
  
  // zmq_subscriber.cpp
  #include "zmq_subscriber.h"
  #include <iostream>
  
  ZMQSubscriber::ZMQSubscriber(const std::string& endpoint, serial::Serial& serial_port)
      : context_(1), socket_(context_, ZMQ_SUB), serial_port_(serial_port) {
      socket_.connect(endpoint); // 连接到 PC 的发布端
      socket_.setsockopt(ZMQ_SUBSCRIBE, "", 0); // 订阅所有消息
  }
  
  void ZMQSubscriber::run() {
      while (true) {
          zmq::message_t message;
          if (socket_.recv(&message)) {
              std::string flag_str(static_cast<char*>(message.data()), message.size());
              int flag = std::stoi(flag_str); // "1" 或 "0"
  
              // 通过串口转发标志位
              serial_port_.write(flag_str); // 发送 "1" 或 "0"
  
              std::cout << "Received flag: " << flag_str << std::endl;
          }
      }
  }
  ```

  

`unxz .img.xz `

## 鲁班猫

卡片电脑、版对版、B2B

- 型号：<img src="/home/wybie/.config/Typora/typora-user-images/image-20250718195927022.png" alt="image-20250718195927022" style="zoom:50%;" />

## 工控机选型

### 雷神

- **雷神MIX**：7499￥

  | **配置项目**        | **详细参数**                                                 |
  | :------------------ | :----------------------------------------------------------- |
  | **产品型号**        | 雷神MIX G1362H026LD                                          |
  | **操作系统**        | Windows 11                                                   |
  | **主板芯片组**      | 其他（未明确标注具体型号）                                   |
  | **处理器（CPU）**   | Intel Core i7-13620H                                         |
  | **处理器核芯数**    | 10 核（具体为 6 性能核 + 4 能效核）                          |
  | **显卡（GPU）**     | NVIDIA GeForce RTX 4060                                      |
  | **散热方式**        | 风冷散热                                                     |
  | **显卡显存**        | 8 GB GDDR6（通常为独立显存）                                 |
  | **内存（RAM）**     | 16 GB（原机配置，一般为 DDR4/DDR5）                          |
  | **存储类型**        | 无机械硬盘（即无 HDD）                                       |
  | **固态硬盘（SSD）** | 512 GB（具体协议如 PCIe NVMe 未注明）                        |
  | **电源适配器**      | 120W 电源适配器                                              |
  | **机箱尺寸**        | 150mm × 150mm × 52mm（非常规笔记本尺寸，可能为迷你主机或特殊形态） |

雷神MIX G139H047LD的处理器是i9

- **MIX PRO**：高性能4999￥～3299￥

  | **配置项目**        | **详细参数**                                                 |
  | :------------------ | :----------------------------------------------------------- |
  | **产品型号**        | 雷神 MIX PRO MT125H00                                        |
  | **操作系统**        | 无（未预装操作系统）                                         |
  | **主板芯片组**      | 其他（未明确具体型号）                                       |
  | **处理器（CPU）**   | Intel Ultra 5 125H                                           |
  | **处理器核芯数**    | 14 核（通常为性能核+能效核组合）                             |
  | **显卡（GPU）**     | 集成显卡（核显，具体型号未标明）                             |
  | **散热器**          | 风冷散热                                                     |
  | **显卡显存**        | 无（集成显卡一般无独立显存）                                 |
  | **内存（RAM）**     | 无（未预装内存条）                                           |
  | **机械硬盘**        | 无（未配置 HDD）                                             |
  | **固态硬盘（SSD）** | 无（未配置 SSD）                                             |
  | **机箱尺寸**        | 70mm × 70mm × 30mm（极小体积，可能为迷你设备/开发板/准系统等） |

### NUC

![img](https://pic1.zhimg.com/v2-c00eae214c861ef8fe1978c2a9c72d1a_1440w.jpg)

- **15pro**：4399￥

  | **配置项目**                | **NUC15CRK-B**                                               | **NUC15CRH-B**                                               |
  | :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
  | **型号**                    | NUC15CRK-B                                                   | NUC15CRH-B                                                   |
  | **产品形态（Form Factor）** | Kit（套件，需自行安装内存和硬盘）                            | Kit（套件，需自行安装内存和硬盘）                            |
  | **操作系统**                | 无预装操作系统（支持：Windows 11、RedHat Enterprise Linux、Ubuntu 24.04 LTS） | 无预装操作系统（支持：Windows 11、RedHat Enterprise Linux、Ubuntu 24.04 LTS） |
  | **处理器（CPU）**           | Intel® Core™ 3 Processor 100U，cTDP 25W                      | Intel® Core™ Ultra 5 225H，cTDP 40W Intel® Core™ Ultra 7 255H，cTDP 40W Intel® Core™ 7 Processor 240H，cTDP 25W |
  | **芯片组**                  | 集成                                                         | 集成                                                         |
  | **显卡（GPU）**             | Intel® Graphics（集成显卡）                                  | Intel® Arc™ GPU（核显，来自 Core Ultra，**需搭配 2 条 SO-DIMM 内存使用**） Intel® Graphics（部分型号为集成显卡） |
  | **内存（RAM）**             | 无预装 最大支持：48GB（DDR5-5600 SO-DIMM ×2 或 DDR5-6400 CSO-DIMM ×2） | 无预装 最大支持：48GB（DDR5-5600 SO-DIMM ×2 或 DDR5-6400 CSO-DIMM ×2） |
  | **存储（硬盘）**            | 无预装 支持： - M.2 2280 NVMe™ PCIe 5.0 x4 SSD（Core Ultra CPU，最高 8TB） - M.2 2280 PCIe 4.0 x4 SSD（Core 系列，最高 8TB） - M.2 2242 PCIe 4.0 x4 SSD（最高 2TB） | 无预装 支持： - M.2 2280 NVMe™ PCIe 5.0 x4 SSD（Core Ultra，最高 8TB） - M.2 2280 PCIe 4.0 x4 SSD（Core 系列，最高 8TB） - M.2 2242 PCIe 4.0 x4 SSD（最高 2TB） |
  | **无线网络（Wi-Fi & BT）**  | Intel® Wi-Fi 7 BE202，蓝牙 5.4（蓝牙版本可能随操作系统变化） | Intel® Wi-Fi 7 BE201，蓝牙 5.4（蓝牙版本可能随操作系统变化） |
  | **有线网络（LAN）**         | Intel® Ethernet Controller I226-V，2.5G 以太网               | Intel® Ethernet Controller I226-V，2.5G 以太网               |
  | **前置 I/O 接口（侧面）**   | - 1 × USB 3.2 Gen2x2 Type-C - 2 × USB 3.2 Gen2 Type-A - 1 × Kensington 安全锁孔 | - 1 × USB 3.2 Gen2x2 Type-C - 2 × USB 3.2 Gen2 Type-A - 1 × Kensington 安全锁孔 |
  | **后置 I/O 接口**           | - 2 × HDMI 2.1（兼容 TMDS，4K@60Hz） - 2 × Thunderbolt™ 4（含 DP 2.1 和 USB4） - 1 × USB 3.2 Gen2 Type-A - 1 × USB 2.0 Type-A - 1 × RJ45 网口 - 1 × DC 电源输入 | - 2 × HDMI 2.1（兼容 TMDS，4K@60Hz） - 2 × Thunderbolt™ 4（含 DP 2.1 和 USB4） - 1 × USB 3.2 Gen2 Type-A - 1 × USB 2.0 Type-A - 1 × RJ45 网口 - 1 × DC 电源输入 |
  | **电源适配器**              | 19VDC, 4.74A, 90W（适用于 Intel® Core™ i3 100U 25W CPU）     | 19VDC, 6.32A, 120W（适用于 Core Ultra 系列 40W CPU）         |
  | **尺寸（宽 × 深 × 高）**    | 117mm × 112mm × 37mm                                         | 117mm × 112mm × 54mm                                         |
  | **重量**                    | 500g                                                         | 600g                                                         |

- **15pro** **plus**：5641￥

  | **配置项目**                   | **详细参数**                                                 |
  | :----------------------------- | :----------------------------------------------------------- |
  | **型号（Model）**              | NUC15CRS-B                                                   |
  | **产品形态（Form Factor）**    | Kit（套件 / 准系统，需自行安装内存、硬盘和操作系统）         |
  | **操作系统（OS）**             | 无预装操作系统（No preinstalled OS） **支持系统**： • Windows 11 • RedHat Enterprise Linux • Ubuntu 24.04 LTS |
  | **处理器（CPU）**              | 可选配置（具体发货型号可能不同）： • **Intel® Core™ Ultra 7 Processor 265H（支持 vPro），cTDP 40W** • Intel® Core™ Ultra 7 255H，cTDP 40W • Intel® Core™ Ultra 5 225H，cTDP 40W • **Intel® Core™ Ultra 9 285H，cTDP 65W** • Intel® Core™ Ultra 5 235H（支持 vPro），cTDP 40W |
  | **芯片组（Chipset）**          | 集成（Integrated）                                           |
  | **显卡（GPU）**                | **Intel® Arc™ GPU（核显，基于 Core Ultra 架构）** • *需安装 2 条 SO-DIMM 内存（双通道）才能启用完整功能* |
  | **内存（RAM）**                | 无预装内存 **最大支持容量**： • 48GB（2×24GB） ▪ DDR5-5600 SO-DIMM × 2 ▪ 或 DDR5-6400 CSO-DIMM × 2 |
  | **存储（硬盘）**               | 无预装存储 **支持类型与容量**： • **M.2 2280 NVMe™ PCIe 5.0 x4 SSD**：128GB ~ 8TB（适用于 Core Ultra 系列 CPU） • **M.2 2280 NVMe™ PCIe 4.0 x4 SSD**：128GB ~ 8TB（适用于 Core 系列 CPU） • **M.2 2242 NVMe™ PCIe 4.0 x4 SSD**：128GB ~ 2TB |
  | **无线网络（Wi-Fi & BT）**     | • **Intel® Wi-Fi 7 BE201** • **Bluetooth 5.4** • *蓝牙版本可能因操作系统不同而有所变化* |
  | **有线网络（LAN）**            | • **Intel® Ethernet Controller I226-LM，2.5G** • **Intel® Ethernet Controller I226-V，2.5G** |
  | **音频输出**                   | 支持最高 7.1 声道（或 8 声道）数字音频，通过 **HDMI 与 Thunderbolt / DP 接口** 输出 |
  | **TPM 安全芯片**               | 支持（FTPM，固件级可信平台模块，常见于此类NUC产品，文档中虽未明确写明，但通常内置） |
  | **读卡器（Card Reader）**      | 无                                                           |
  | **前置 I/O 接口（侧面）**      | • 1 x **USB 3.2 Gen2x2 Type-C** • 2 x **USB 3.2 Gen2 Type-A** |
  | **后置 I/O 接口**              | • 2 x **HDMI 2.1 TMDS 兼容（支持 4K@60Hz）** • 2 x **Thunderbolt™ 4 端口**（包含 DP 2.1 和 USB4） • 1 x **USB 3.2 Gen2 Type-A** • 1 x **USB 2.0 Type-A** • 1 x **RJ45 2.5G 网口** • 1 x **DC 电源输入** • 1 x **Kensington 安全锁孔** |
  | **侧面 I/O 接口**              | 无（N/A）                                                    |
  | **电源适配器（Power Supply）** | • **19VDC, 6.32A, 120W**（适用于大多数 Core Ultra 系列 CPU，如 265H / 255H / 225H / 235H） • **19.5VDC, 7.69A, 150W**（适用于 **Intel® Core™ Ultra 9 285H，cTDP 65W** 高性能型号） |
  | **产品尺寸（宽 × 深 × 高）**   | **144mm × 112mm × 42mm**                                     |
  | **产品重量**                   | **600g**                                                     |

**不包含内存条、固态硬盘、操作系统**，属于 **准系统（Barebone）**，用户需 **自行购买并安装内存、硬盘和系统后才能正常使用**->

- **Intel Arc 核显（尤其是 Core Ultra 系列中的核显）没有独立的显存（VRAM）**，它是直接调用系统的内存（RAM）作为显存来处理图形任务的。

- •当内存运行在 **单通道模式** 下时，核显访问内存的 **带宽受限，数据传输速度较慢**，会 **明显影响图形性能，尤其是在高分辨率、视频解码、3D 渲染、AI 加速等场景下**。

- **14** **pro** **ai**: 4799￥

  | **配置项目**                    | **详细参数**                                                 |
  | :------------------------------ | :----------------------------------------------------------- |
  | **型号（Model）**               | ASUS NUC 14 Pro AI Kit (NUC14LNK)                            |
  | **产品形态（Form Factor）**     | **Kit（准系统 / 套件）** —— 需用户自行安装硬盘（但已预装内存） |
  | **操作系统（OS）**              | 无预装操作系统（No preinstalled OS） **支持系统**： • Windows 11 Pro • Windows 11 Home |
  | **处理器（CPU）**               | **Intel® Core™ Ultra 7 Processor 258V，cTDP 30W** （低功耗高性能移动处理器，适合轻薄/迷你设备） |
  | **芯片组（Chipset）**           | 集成（Integrated）                                           |
  | **显卡（GPU）**                 | **Intel® Arc™ Graphics** • **140V（适用于 Ultra 7 / Ultra 9）** • **130V（适用于 Ultra 5）** （基于 Intel 最新架构的集成核显，性能接近入门独显） |
  | **内存（RAM）**                 | **已预装：32GB LPDDR5x-8533，双通道（2ch）** （高频内存，无需用户自行安装，已集成于主板上） |
  | **存储（硬盘）**                | 无预装固态硬盘（No storage included） **支持类型与容量**： • **M.2 2280 NVMe™ PCIe 4.0 x4 SSD** • 容量范围：**256GB ~ 4TB** |
  | **无线网络（Wi-Fi & BT）**      | • **Intel® Wi-Fi 7 BE201** • **Bluetooth 5.4**               |
  | **有线网络（LAN）**             | • **Intel® Ethernet Controller I226-V，2.5G 以太网**         |
  | **音效（Audio）**               | **Realtek ALC3288** 音频芯片，支持高质量音频输出             |
  | **前置（侧面 / 顶部）I/O 接口** | **（顶部）** • 1 x **指纹识别模块（Fingerprint module）**  **（前面板）** • 1 x **电源按钮（Power Button）** • 1 x **Copilot 按钮（微软 AI Copilot 快捷键）** • 1 x **Thunderbolt™ 4 Type-C（支持 DisplayPort 2.1）** • 2 x **USB 3.2 Gen1 Type-A** • 1 x **3.5mm 耳机插孔（Headset Jack）**  **（侧面）** • 1 x **Kensington 安全锁孔（Kensington Lock Slot）** |
  | **后置 I/O 接口**               | • 1 x **Thunderbolt™ 4 Type-C（支持 DisplayPort 2.1）** • 2 x **USB 3.2 Gen2 Type-A** • 1 x **HDMI 2.1（TMDS 兼容，支持 4K 视频输出）** • 1 x **2.5G RJ45 以太网口（LAN）** • 1 x **DC 电源输入接口** |
  | **产品尺寸（宽 × 深 × 高）**    | **130mm × 130mm × 34mm**（非常小巧，适合空间有限环境）       |
  | **产品重量**                    | **500g**（极轻，便于携带与部署）                             |

- **14** **pro** **plus**：￥7899

  | 规格类别       | 型号：NUC14RVS                                               | 型号：NUC14RVS-B                                             |
  | :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
  | **型号**       | NUC14RVS                                                     | NUC14RVS-B                                                   |
  | **外形规格**   | Mini PC                                                      | Mini PC                                                      |
  | **套件类型**   | 操作系统套件                                                 | 裸机套件                                                     |
  | **操作系统**   | Windows 11 Home 支持：Windows 11, Chrome OS Flex, RedHat Enterprise Linux, Ubuntu 24.04 LTS | 无预装系统 支持：Windows 11, Chrome OS Flex, RedHat Enterprise Linux, Ubuntu 24.04 LTS |
  | **处理器**     | Intel® Core™ Ultra 9 185H (cTDP 65W) Intel® Core™ Ultra 5 125H (cTDP 40W) Intel® Core™ Ultra 7 155H (cTDP 40W) | Intel® Core™ Ultra 5 125H (cTDP 40W) Intel® Core™ Ultra 7 155H (cTDP 40W) Intel® Core™ Ultra 9 185H (cTDP 65W) |
  | **芯片组**     | 集成                                                         | 集成                                                         |
  | **显卡**       | Intel® Arc™ Graphics (Core Ultra系列)* Intel® Graphics (Core3系列) *Intel® Arc™ GPU需使用2×SO-DIMM | Intel® Arc™ Graphics (Core Ultra系列)* Intel® Graphics (Core3系列) *Intel® Arc™ GPU需使用2×SO-DIMM |
  | **内存**       | 最大容量：48GB DDR5-5600 SO-DIMM ×2 包含：16GB DDR5-5600 SO-DIMM ×2 包含：8GB DDR5-4800 SO-DIMM ×2 | 最大容量：48GB DDR5-5600 SO-DIMM ×2 发货时不包含内存         |
  | **硬盘**       | 支持： • 128GB~4TB M.2 2280 NVMe™ PCIe® 4.0 ×4 SSD • 128GB~2TB M.2 2242 NVMe™ PCIe® 4.0 ×4 SSD 包含：1TB/512GB M.2 2280 NVMe™ PCIe® 4.0 SSD | 支持： • 128GB~4TB M.2 2280 NVMe™ PCIe® 4.0 ×4 SSD • 128GB~2TB M.2 2242 NVMe™ PCIe® 4.0 ×4 SSD 发货时不包含存储 |
  | **无线网络**   | Intel® Wi-Fi 6E AX211 (Gig+), Bluetooth 5.3                  | Intel® Wi-Fi 6E AX211 (Gig+), Bluetooth 5.3                  |
  | **有线网络**   | Intel® Ethernet Controller I226-V, 2.5G                      | Intel® Ethernet Controller I226-V, 2.5G                      |
  | **前置接口**   | 1 × USB 3.2 Gen2×2 Type-C 2 × USB 3.2 Gen2 Type-A 1 × Kensington锁孔 | 1 × USB 3.2 Gen2×2 Type-C 2 × USB 3.2 Gen2 Type-A 1 × Kensington锁孔 |
  | **后置接口**   | 2 × Thunderbolt 4 Type-C (DisplayPort 1.4) 1 × USB 3.2 Gen 2 Type-A 1 × USB 2.0 Type-A 2 × HDMI 2.1 (TMDS) 1 × RJ45 LAN 1 × DC电源输入 1 × Kensington锁孔 | 2 × Thunderbolt 4 Type-C (DisplayPort 1.4) 1 × USB 3.2 Gen 2 Type-A 1 × USB 2.0 Type-A 2 × HDMI 2.1 (TMDS) 1 × RJ45 LAN 1 × DC电源输入 1 × Kensington锁孔 |
  | **电源适配器** | 19VDC, 6.32A, 120W (Core Ultra系列) 19.5VDC, 7.69A, 150W (Core Ultra 9) | 19VDC, 6.32A, 120W (Core Ultra系列) 19.5VDC, 7.69A, 150W (Core Ultra 9) |
  | **尺寸**       | 144mm × 112mm × 41mm                                         | 144mm × 112mm × 41mm                                         |
  | **重量**       | 600g                                                         | 600g                                                         |

### jetson

跳楼降价->https://gitmind.cn/app/docs/mul49bme

参数简介：

图为的网上资料很多，官网资源中心基本可以查到全部参数。我们队里主要有 Orin NX 系列和 Xavier NX 系列，但因为 Xavier NX 的视觉推理性能和 Orin NX 相比差了大概 50 倍（AI TOPS：20 vs 100），它在实时检测这种任务上完全不够用，所以没做考虑。我们主要对比的是 AGX Orin 和 Orin NX 系列。

选型的时候最核心的参数就是功耗、内存、CPU 和 GPU。功耗方面，队里现在的充电宝根据硬件计算最大可以提供 100W 左右（300￥张威学长买的，电流输出动态调节根据负载需要变化），供电能力理论上是够撑住 Orin NX 和低功耗模式的 AGX Orin 的。

同一款机型根据内存大小会有不同版本，主要是 8GB、16GB、32GB、64GB 几种选择。不同内存配置价格可以差两千到八千不等。这里的原因是 Jetson 用的是统一内存架构，也就是说 GPU 向 CPU 申请内存、SLAM 建图占内存、点云和图像缓存都在抢同一块内存。内存不够就会交换分页（交换后速度会变慢），出现突然卡顿、掉帧这种问题，所以视觉任务越重，内存越大越好。

CPU 方面，首先核心数量越多能开得起的线程越多，比如视觉推理、定位导航、通讯、路径规划都可以同时跑，响应速度会更稳定。然后 MBL2 和 MBL3，这个缓存越大，CPU 访问内存的延迟越低，对矩阵计算（视觉用）和多线程调度（雷达和视觉并行计算）都很关键。

GPU 方面，GPU 的 CUDA 核心数和 Tensor Core 数量直接影响深度学习的计算速度，也就是神经网络张量（tensor）的计算效率。AI TOPS 就是衡量推理性能的主要指标，它越高，实时识别的帧率越高、延迟越低。AGX Orin 系列除了体积更大、供电要求更高以外，主要升级的就是 GPU 数量和算力，所以深度学习推理速度会明显提升。

另外还有一些容易被忽略但实际影响很大的参数：例如 PCIe 通道数量、NVMe 存储速度、显存带宽等。AGX Orin 的扩展能力会更强，比如上双雷达、多相机、超高分辨率相机时带宽不卡。目前rm用的就是双雷达，主要为了看360度场景点云消噪，但是感觉他们用的主要原因是因为赛事要求上应用场景变化很多，具体需求可以看雷达那边开发计划；那边用的雷神MIXi710核跑导航和自瞄cpu使用率50%，801（现在车上的）听宁博样跑3D导航抱怨过运存不够的问题

#### 什么是网口？

**网口**，也称为以太网接口，是基于以太网协议的网络接口，主要用于连接局域网（LAN）和广域网（WAN）。网口通过物理层的传输介质（如双绞线或光纤）将数据帧传输到目标设备，并在数据链路层解包提取MAC地址，进而在网络层进行路由

#### sd卡和emmc卡都是存储设备，什么是emmc？

**eMMC卡（嵌入式多媒体卡）是一种广泛应用于智能手机、平板电脑、数码相机等移动设备的存储解决方案。**

#### 什么是sdk？

**SDK**（Software Development Kit，软件开发工具包）是为开发者提供的一组工具、库和文档，用于构建特定平台、操作系统或应用程序的软件。它可以帮助开发者快速实现某些功能，而无需从零开始开发。SDK 通常包含编译器、调试器、API、示例代码、文档以及测试工具等。

- host口：通过HOST口连接外部设备时，**鲁班猫充当“电脑”角色**，外部设备（如U盘、键盘、鼠标等）充当“从设备”

#### 什么是dns？

**DNS（域名系统，Domain Name System）** 是互联网的核心服务之一，用于将人类易读的域名（如 *www.google.com*）转换为计算机可识别的IP地址（如 *192.168.1.1*）。这种转换机制使用户无需记住复杂的数字地址即可访问网络资源。

**nfs**：NFS（Network File System，网络文件系统）是由Sun Microsystems公司于1984年推出的一种远程文件访问协议。它允许不同计算机上的应用程序通过网络访问彼此的文件系统，就像访问本地文件系统一样

**ftp**：**FTP**（**File Transfer Protocol**）是一种在网络中进行文件传输的标准协议。作为网络通信中的基础工具，FTP允许用户通过客户端软件与服务器进行交互，实现文件的上传、下载和其他文件操作。FTP工作在OSI模型的应用层，通常使用TCP作为其传输协议，确保数据传输的可靠性和顺序性。

- 设备树：LubanCat-RK3562/RK3566/RK3568系列的板子的设备树插件位于 **/boot/dtb/overlay** 里

主机板卡连接：https://doc.embedfire.com/linux/rk356x/quick_start/zh/latest/quick_start/gcc_compile/gcc_compile.html



**嵌入式DisplayPort（eDP）**：这是一种用于连接LCD屏幕的高带宽数字接口，主要应用于笔记本电脑、平板电脑等设备。eDP能够传输高分辨率视频信号，并支持音频和控制信号的传输，具有低功耗的特点。 

**dsi**：DSI（Display Serial Interface）接口是一种用于连接[显示器](https://www.eefocus.com/baike/488773.html)和[处理器](https://www.eefocus.com/tag/处理器/)之间的[串行通信](https://www.eefocus.com/baike/1555795.html)接口标准。它主要用于移动设备、[嵌入式系统](https://www.eefocus.com/baike/502953.html)和其他电子产品中，实现高速、[低功耗](https://www.eefocus.com/tag/低功耗/)的显示[数据传输](https://www.eefocus.com/tag/数据传输/)。

- 屏幕类别：

  **RGB接口** 是一种通过红、绿、蓝三通道传输颜色数据的接口，分为并行和串行两种类型。并行RGB接口支持高分辨率（如1920x1080），但需要同步信号（如VSYNC、HSYNC）和时钟信号（DCLK）。串行RGB接口则适用于较低分辨率（如800x480），数据传输速率较低。

  **LVDS接口** 是一种低压差分信号接口，主要用于大屏显示。它通过差分信号传输数据，具有低功耗、抗干扰能力强的特点。LVDS支持单路和双路传输，分辨率可达1920x1080，适用于车载屏幕和工业显示器。

  **MIPI接口** 是一种高速串行接口，广泛应用于移动设备。其特点是高带宽（如1Gbps/Lane）、低功耗和抗干扰能力强。MIPI-DSI模式分为Command Mode和Video Mode，支持高分辨率显示（如2048x1536@60fps），适用于手机和平板等设备。

  **HDMI接口** 是一种数字多媒体接口，可同时传输音频和视频信号。HDMI支持高分辨率（如4096x2160@60Hz）和高带宽（如HDMI 2.0的6Gbps），并具有HDCP版权保护功能。它是电视、机顶盒和游戏主机的主流接口。

用`evtest`命令获取屏幕的驱动设备

- **输入设备**：linux-event-codes.h文件定义了输入事件的类型和代码，用于描述和标识各种输入设备（如键盘、鼠标、触摸屏等）生成的事件。

  修改设备参数，从linux-event_codes.h中修改事件，再写一个.c文件传递参数并从输入事件中循环读取，最后运行命令

  ```
  #编译
  gcc buttons.c -o buttons
  
  #运行，需要指定实际的pwm-event
  sudo ./buttons /dev/input/event0
  ```

- **硬盘**：https://doc.embedfire.com/linux/rk356x/quick_start/zh/latest/quick_start/disk_mount/disk_mount.html

**路由器模式**：

**AP模式**（Access Point模式）是无线接入点模式，主要用于连接有线网络和无线网络。只需要把一根可以上网的网线插在路由器上，无需任何配置就可以通过有线和无线上网了

在**Router（无线路由）**模式下，路由器就相当于一台普通的无线宽带路由器；平时我们使用的都是这种模式。需要连接ADSL Modem（猫）或者光猫等设备来进行配置。

**Repeater（中继）**模式，**Bridge（桥接）**模式下，路由器会通过无线的方式与一台可以上网的无线路由器建立连接，用来放大可以上网的无线路由器上的无线信号

两者区别在于Repeater（中继）模式下放大后的无线信号名称和之前路由器上的一致，而Bridge（桥接）模式放大后的无线信号名称和之前路由器上的无线信号名称不同。

**什么是宽带、光猫、路由器、wifi？**

https://www.zhihu.com/question/446999607

## linux系统开发

## 操作I2C

```
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>

int main() {
    int fd;
    const char *i2c_device = "/dev/i2c-1";  // 树莓派一般是 i2c-1
    int addr = 0x68; // 设备地址 (MPU6050)

    // 打开 I2C 设备
    if ((fd = open(i2c_device, O_RDWR)) < 0) {
        perror("Failed to open i2c device");
        exit(1);
    }

    // 绑定从设备地址
    if (ioctl(fd, I2C_SLAVE, addr) < 0) {
        perror("Failed to set I2C address");
        close(fd);
        exit(1);
    }

    // 写寄存器地址 (比如读取寄存器 0x75)
    uint8_t reg = 0x75;
    if (write(fd, &reg, 1) != 1) {
        perror("Failed to write register address");
    }

    // 读回数据
    uint8_t data;
    if (read(fd, &data, 1) != 1) {
        perror("Failed to read data");
    } else {
        printf("WHO_AM_I register: 0x%02X\n", data);
    }

    close(fd);
    return 0;
}
```

编译：

```
gcc i2c_test.c -o i2c_test
```

运行：

```
sudo ./i2c_test
```

## 操作SPI

```
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/spi/spidev.h>

int main() {
    int fd;
    const char *spi_device = "/dev/spidev0.0"; // bus 0, cs 0

    // 打开 SPI
    if ((fd = open(spi_device, O_RDWR)) < 0) {
        perror("Failed to open spidev");
        exit(1);
    }

    // 配置 SPI 参数
    uint8_t mode = SPI_MODE_0;
    uint8_t bits = 8;
    uint32_t speed = 1000000; // 1MHz

    ioctl(fd, SPI_IOC_WR_MODE, &mode);
    ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);
    ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);

    // 构造传输数据
    uint8_t tx[] = {0x9F}; // SPI Flash 读取 JEDEC ID 指令
    uint8_t rx[3] = {0};

    struct spi_ioc_transfer tr = {
        .tx_buf = (unsigned long)tx,
        .rx_buf = (unsigned long)rx,
        .len = sizeof(tx) + sizeof(rx),
        .speed_hz = speed,
        .bits_per_word = bits,
    };

    // 执行传输
    if (ioctl(fd, SPI_IOC_MESSAGE(1), &tr) < 1) {
        perror("Failed to send SPI message");
    } else {
        printf("JEDEC ID: %02X %02X %02X\n", rx[0], rx[1], rx[2]);
    }

    close(fd);
    return 0;
}

```

编译：

```
gcc spi_test.c -o spi_test
```

运行：

```
sudo ./spi_test
```

# ==很杂的知识==

- ```
  sync # 将数据由内存同步到硬盘中。
  ```

### **什么是Qos？**

QoS（**Quality of Service，服务质量**）是计算机网络和通信领域中的关键技术，用于**管理和优化网络资源分配，确保关键业务或应用获得所需的网络性能保障**（如低延迟、高带宽、低丢包率）。其核心目标是解决网络拥塞时不同数据流之间的竞争问题，优先处理重要任务（如视频会议、在线手术），避免普通流量（如文件下载）影响关键服务的体验。

### **什么是mmu？**

https://blog.csdn.net/KUNPLAYBOY/article/details/121157550

### **==编译工具==：**

类别	工具列表
核心工具	as, gcc, ld, ar, objdump, readelf
符号处理	nm, c++filt, strip, ranlib
调试分析	gprof, addr2line, strings, size
特殊用途	windmc, windres, elfedit, gold, lto-dump
辅助工具	m4, bfd, cpp

- **交叉编译器**：用来编译跨平台的程序的编译器（arm、x86不互通）

  交叉编译器运行在 **一个平台（Host）** 上，但生成的代码是运行在 **另一个平台（Target）** 上的。

  - **Host（宿主机）**：运行编译器的机器（如你的开发机，通常是 x86_64 Linux/Windows/macOS）。
  - **Target（目标机）**：运行编译后程序的机器（如 ARM 嵌入式设备、RISC-V 单板计算机等）。

https://blog.csdn.net/usstmiracle/article/details/130985974

### **bootloader**:

正式运行代码前搭建合适环境的程序，硬件初始化，创建传递内核信息并建立内存空间的映射图

![](主机.assets/image-20250805081839448.png)

- **pc初始化**：硬盘启动和软盘启动
- 异常中断时，进入中断状态并备份状态到寄存器

### ==**设备驱动**==：

1. 字符设备

   **特点**：按 **字节流**（stream）方式顺序读写，不支持随机访问。

   **接口**：通过 `open`、`read`、`write`、`ioctl` 等系统调用访问。

   **例子**：串口 `/dev/ttyS0`，I2C `/dev/i2c-1`，SPI `/dev/spidev0.0`，GPIO `/dev/gpiochip0`，传感器驱动等。

   **使用场景**：逐字节交互、流式数据传输。

2. 块设备

   **特点**：以 **固定大小的数据块**（通常是 512B 或 4KB）为单位读写，支持 **随机访问**。

   **接口**：通过文件系统接口访问（`open`, `read`, `write`, `lseek`），通常挂载成目录使用。

   **例子**：硬盘 `/dev/sda`，SD 卡 `/dev/mmcblk0`，U 盘 `/dev/sdb`，eMMC，NAND Flash。

   **使用场景**：大容量存储，需要随机访问。

3. 网络设备

   **特点**：不通过 `/dev/*` 文件访问，而是通过 **socket API** 进行通信。

   **接口**：`socket`、`send`、`recv`、`bind`、`connect` 等。

   **例子**：以太网 `eth0`，WiFi `wlan0`，虚拟网卡 `lo`，CAN 总线 `can0`。

   **使用场景**：点对点或广播通信，TCP/UDP/IP 协议栈。

### zmq通信：

  全名ZeroMQ，ZMQ是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入Linux内核

​		有三种模式：应答模式、发布订阅模式、管道模式

<img src="https://i-blog.csdnimg.cn/blog_migrate/54f4ef57fe30bf5daeafdca123cf4605.png" alt="img" style="zoom: 67%;" />

![image-20250726080722593](主机.assets/image-20250726080722593.png)

![image-20250726081512368](主机.assets/image-20250726081512368.png)

### **串口的冷门知识**：

**串口常见电平和区别**

串口的类型其实不止一种，串口常用的电平有三种：TTL、RS232、RS485，还有一种不常见的RS422，不常用的我就不说了，我主要讲一下常用的这三种电平的区别。
TTL：电压范围0V至+5V，高电平>2.4V，低电平<0.4V，一般MCU直接输出的串口就是TTL电平的。
RS232：电压范围-15V至+15V，高电平为-3V至-15V，低电平为+3V至+15V。
RS485：电压范围-7V至+12V，不同于TTL和RS232，RS485采用的差分信号负逻辑，高电平为两线间的电压差-2V至-6V，低电平为两线间的电压差+2V至+6V。
三种电平之间不能直接连接，需要通过转换芯片改变电平，一般MCU端出来的电平都是TTL。
如果MCU的串口需要连接到PC端，一般有三种方法：
1、通过一个USB转TTL的芯片转换，可以放在主板上，也可以用那种转换小板，这个大家应该比较熟悉了，某宝上面随处可见。
2、通过一个TTL转232的芯片转换，然后再接一根USB转232的连接线，常用DB9接口。
3、通过一个TTL转485的芯片转换，然后再接一根USB转485的连接线。
TTL一般是板内模块间通讯用的比较多，因为串口线过长会有线损，影响通讯，因此，外接的传感器和MCU的通讯大多使用RS232和RS485这两种，像RS485，串口线即使长达一百米，也不影响正常通讯。

![image-20250805091249492](主机.assets/image-20250805091249492.png)

**软件流控 vs 硬件流控**

软件流控是通过在数据流中插入特殊的控制字符，来通知对方 “暂停发送” 或 “继续发送”，是一种基于软件 / 数据内容的流控方式。

| 控制字符 | ASCII 码          | 含义                                   |
| :------- | :---------------- | :------------------------------------- |
| **XOFF** | **0x13** (Ctrl+S) | **停止发送**：告诉对方暂停发送数据     |
| **XON**  | **0x11** (Ctrl+Q) | **继续发送**：告诉对方可以恢复发送数据 |

硬件流控是通过串口通信中的额外硬件信号线（通常是 RTS 和 CTS）来控制数据发送与接收的启停，是一种物理层面的流控机制。

| 引脚名  | 全称                | 功能                                                         |
| :------ | :------------------ | :----------------------------------------------------------- |
| **RTS** | **Request To Send** | **发送请求**：接收方通过此信号告诉发送方：“我可以接收数据，你发吧” |
| **CTS** | **Clear To Send**   | **允许发送**：发送方通过此信号判断：“接收方准备好了，我现在可以发数据” |

- **什么是csi？**

https://blog.csdn.net/weixin_41192637/article/details/115114052

### **数据流格式**

1. **应用层**：浏览器生成 HTTP 请求（如 `GET /index.html`）。
2. **传输层**：HTTP 数据通过 **TCP** 封装为 TCP 报文（添加源/目标端口，如 80）。
3. **网络层**：TCP 报文通过 **IP** 封装为 IP 数据包（添加源/目标 IP 地址，如 `192.168.1.100 → 8.8.8.8`）。
4. **数据链路层**：若通过拨号上网，IP 包可能再通过 **PPP** 封装为 PPP 帧，通过电话线传输；若通过以太网，则通过 Ethernet 帧传输。

- **arm汇编语言和arm指令的区别：**

  | 项目         | ARM 汇编语言                    | ARM 指令                      |
  | ------------ | ------------------------------- | ----------------------------- |
  | **本质**     | 一种低级编程语言                | 二进制机器码                  |
  | **表现形式** | 可读的助记符（如 `MOV R0, #1`） | 如 `0xE3A00001`               |
  | **执行者**   | 被汇编器（assembler）转换为指令 | 被 ARM CPU 直接执行           |
  | **编写者**   | 人类工程师                      | CPU 读取执行                  |
  | **代表工具** | `.s` 或 `.asm` 文件             | `.bin` 或 `.elf` 中的指令数据 |

```
C语言代码 -> 编译器 (gcc) -> 汇编代码 (.s)
汇编代码  -> 汇编器 (as) -> 机器码 (.o)
机器码    -> 链接器 (ld) -> 可执行文件 (.elf)
```

### **==cpp编译链==：**

```
           +----------------+
           |  .cpp / .h     |
           +--------+-------+
                    |
           [1] 预处理器（cpp）
                    |
           +--------v--------+
           |   .i 文件       |  // 展开宏和头文件
           +--------+--------+
                    |
           [2] 编译器前端（cc1plus）
                    |
           +--------v--------+
           |   .s 文件       |  // 汇编代码
           +--------+--------+
                    |
           [3] 汇编器（as）
                    |
           +--------v--------+
           |   .o 文件       |  // 目标文件
           +--------+--------+
                    |
           [4] 链接器（ld / g++）
                    |
           +--------v--------+
           | 可执行文件 ELF |
           +----------------+
```



- 在 Linux 上使用实时操作系统（RTOS）或构建“类实时”系统，可以通过 实时 Linux（Real-Time Linux）技术来实现**PREEMPT_RT**


### **MCU和MPU的区别**

| 项目     | MCU（微控制器）                                   | MPU（微处理器）                             |
| -------- | ------------------------------------------------- | ------------------------------------------- |
| 定义     | 集成了处理器、存储器、IO接口的**片上系统（SoC）** | 仅包含处理器核心（CPU），依赖外部内存和外设 |
| 使用场景 | 实时控制、小型嵌入式系统                          | 高性能计算、复杂操作系统（如 Linux）运行    |
| 实时性   | 通常具备良好的实时性                              | 实时性差，需要专用 RT 内核支持              |
| 成本     | 低                                                | 高                                          |
| 功耗     | 极低（毫瓦级）                                    | 通常更高（瓦级）                            |
| 外设集成 | 高（如 ADC、PWM、UART、I2C、SPI）                 | 少（大多数外设需外挂）                      |
| 存储器   | 片上 SRAM、Flash（如 64KB）                       | 外挂 DDR、Flash（如 GB 级）                 |
| 代表     | STM32、AVR、ESP32、MSP430                         | i.MX6/8、Allwinner、RK3399、树莓派芯片      |

### **CPU和GPU区别：**

| 项目     | CPU（Central Processing Unit）     | GPU（Graphics Processing Unit）       |
| -------- | ---------------------------------- | ------------------------------------- |
| 中文名   | 中央处理器                         | 图形处理器                            |
| 设计目标 | 快速处理少量、复杂的任务（通用）   | 高效处理大量、相同的任务（并行）      |
| 工作方式 | 串行计算（多个核心，处理复杂逻辑） | 并行计算（成百上千个小核心）          |
| 主要用途 | 操作系统控制、逻辑判断、程序调度   | 图像渲染、视频处理、AI 推理、深度学习 |

串行即线性计算，并行为并列计算

- **NVIDIA  jetson系列：**

  | Jetson 模块      | GPU 核心                           | CPU                              | AI 性能     | 推荐用途                       |
  | ---------------- | ---------------------------------- | -------------------------------- | ----------- | ------------------------------ |
  | **Nano**         | 128-core Maxwell                   | Quad-core Cortex-A57             | ~0.5 TFLOPS | 入门级 AI，教育、轻量机器人    |
  | **TX2 NX / TX2** | 256-core Pascal                    | Dual-core Denver + Quad-core A57 | ~1.3 TFLOPS | 中等边缘 AI，自动售货机、安防  |
  | **Xavier NX**    | 384-core Volta + 48 Tensor Cores   | 6-core Carmel CPU                | 21 TOPS     | 中高端 AI，机器人、视觉检测    |
  | **Orin Nano**    | 512-core Ampere + 16 Tensor Cores  | 6-core ARM Cortex-A78AE          | 40 TOPS     | 更强 AI 性能，轻量自动驾驶     |
  | **Orin NX**      | 1024-core Ampere + 32 Tensor Cores | 8-core ARM Cortex-A78AE          | 100 TOPS    | 高性能 AI 边缘部署，工业机器人 |

  **算力指标：**

  - **TOPS**：整数运算相对简单，不需要处理小数部分的复杂表示和运算规则，因此在硬件实现上相对容易，功耗和面积开销通常也较小。不过，其计算精度有限，对于需要高精度小数运算的场景不太适用。
  - **TFLOPS**：浮点运算可以处理更大范围和更高精度的数值，能够满足科学计算、工程模拟等对数值精度要求极高的任务。但浮点运算的实现较为复杂，需要更多的硬件资源和电路来实现小数的存储和运算，因此通常功耗较高、硬件成本也相对较高。

- **带网卡的设备和带网络接口的设备**

  前者数据交换通过外部总线，速度较慢；后者通过内部总线，速度较快

- **fat文件系统格式：**

  保留区、FAT区、根目录区、文件和目录数据区

### **驱动屏幕协议：**

| 接口类型               | 传输方式     | 速度 | 复杂度 | 典型应用               | 说明                     |
| :--------------------- | :----------- | :--- | :----- | :--------------------- | :----------------------- |
| **DPI (Parallel RGB)** | 并行         | 中等 | 低~中  | 嵌入式设备、LCD 屏     | 简单直接，适合中小分辨率 |
| **MIPI DSI**           | **串行**     | 高   | 高     | 手机、平板、高分辨率屏 | 高速串行，节省引脚，复杂 |
| **LVDS**               | 差分串行     | 高   | 中~高  | 笔记本、显示器         | 用于高分辨率、长距离传输 |
| **HDMI / DP**          | 高速串行     | 很高 | 高     | 电视、显示器、显卡     | 消费电子标准接口         |
| **SPI LCD**            | 串行（慢速） | 低   | 低     | OLED 小屏、简单 UI     | 适合极小屏和低速显示     |

| 传输方式             | 说明                                                         |
| :------------------- | :----------------------------------------------------------- |
| **并行（Parallel）** | **多个数据位同时传输**，每个位占用一根独立的线路，在同一时钟周期内一起发送出去 |
| **串行（Serial）**   | **数据一位一位地按顺序传输**，同一时间只传输一个比特，通过单根或少量线路依次发送 |

**base64算法**

Base64是一种二进制到文本的编码方式。如果要更具体一点的话，可以认为它是一种将 `byte`数组编码为字符串的方法，而且编码出的字符串只包含[ASCII](https://zhida.zhihu.com/search?content_id=173517102&content_type=Article&match_order=1&q=ASCII&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTM2NjQxMzEsInEiOiJBU0NJSSIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjE3MzUxNzEwMiwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.mQwgoGFGnNFhG7N7cbMLLH_apuuBOvXxbSzqAsVSRLI&zhida_source=entity)基础字符。

![image-20250728193430569](主机.assets/image-20250728193430569.png)

- **libcurl库**

  cURL 这个项目包含了 libcurl 和 curl 两个产品。
  其中，libcurl 是一个客户端的 URL 支持库；而 curl 就是一个使用了 libcurl 库写出来的命令行工具，其可以使用 URL 标识来请求或者发送文件。

  <img src="https://i-blog.csdnimg.cn/blog_migrate/dfeb4a7f8724702ae3630d45d38ea60e.png" alt="在这里插入图片描述" style="zoom: 50%;" />

  支持协议：

  |           协议           |               说明               |
  | :----------------------: | :------------------------------: |
  |     **HTTP / HTTPS**     | 最常用！用于访问网页、API 接口等 |
  |      **FTP / FTPS**      |           文件传输协议           |
  |         **SFTP**         |       基于 SSH 的文件传输        |
  |  **SMTP / IMAP / POP3**  |          发送和接收邮件          |
  |         **LDAP**         |         轻量目录访问协议         |
  |  **WebSocket (实验性)**  |           实时通信协议           |
  | **RTSP, SCP, Telnet 等** |          其他协议也支持          |

  总之，**libcurl 是一个功能强大、简单易用且跨平台的网络传输库，支持 HTTP、HTTPS、FTP 等多种协议，提供 C/C++ 原生接口及 Python、PHP、Java 等多语言绑定，具备 HTTPS 加密、代理、Cookie、认证、文件上传下载等丰富功能，底层采用高效网络 I/O 实现高性能通信，适用于高并发场景，同时拥有直观的 API 设计、完善的文档和大量示例，采用 MIT 开源许可证，可自由商用，是开发网络请求、文件传输、API 调用等功能的理想工具。**

##### 附加

https://blog.csdn.net/m0_73820654/article/details/149497341

- 分辨率更改：

  ```
  xrandr -s
  ```


### **udp和tcp在代码上的区别**

| 功能                   | **TCP（面向连接）**     | **UDP（无连接）**                     |
| :--------------------- | :---------------------- | :------------------------------------ |
| **socket 类型**        | `SOCK_STREAM`           | `SOCK_DGRAM`                          |
| **发送函数**           | `send()`或 `write()`    | `sendto()`或 `send()`（已连接时）     |
| **接收函数**           | `recv()`或 `read()`     | `recvfrom()`或 `recv()`（已连接时）   |
| **是否需要 connect()** | 通常要（除非用 sendto） | 不需要（除非用 connect 绑定默认目标） |

### 主机==内核的主要功能==

1. **进程管理**
   - 创建、调度和终止进程
   - 提供多任务运行（CPU 调度，分时/抢占）
2. **内存管理**
   - 给进程分配和回收内存
   - 虚拟内存机制（让每个进程感觉自己有独立的内存空间）
3. **设备管理**
   - 通过驱动程序访问外设（磁盘、网卡、USB、传感器…）
   - 应用程序不需要知道底层寄存器怎么操作，交给内核里的驱动
4. **文件系统管理**
   - 提供统一的文件接口（打开、读写、关闭）
   - 屏蔽不同存储介质（SSD、HDD、U盘）
5. **网络管理**
   - 提供网络协议栈（TCP/IP）
   - 让应用直接用 socket，而不用关心网卡收发细节

### swap分区的作用

**1. 扩展可用内存**

当系统的 **物理内存（RAM）被占满**，而应用程序仍然需要更多内存时，操作系统会将一部分 **不常使用或暂时不用的内存数据移动（交换）到 Swap 分区中**，从而为当前急需内存的任务腾出 RAM 空间。

这相当于把一部分内存数据“临时存到硬盘上”，虽然硬盘速度远不如内存，但能避免程序因内存不足而崩溃。

------

2. **支持系统休眠（Hibernate）**

在某些 Linux 发行版中，**系统休眠（将当前运行状态保存到磁盘然后关机）功能依赖于 Swap 分区**。
休眠时，系统会将当前内存中的所有数据保存到 Swap 分区中，以便下次开机时能恢复到之前的状态。
因此，​**​若要使用休眠功能，通常要求 Swap 分区的大小至少等于或大于物理内存（RAM）的大小​**​。

------

3. **提高系统稳定性与响应能力**

即使你的物理内存足够大，拥有适量的 Swap 空间也能提高系统的 **稳定性与应变能力**，尤其是在内存使用出现突发峰值时，防止因内存耗尽导致进程被强制终止（OOM，Out Of Memory）。

休眠重启时系统恢复状态，前状态是从swap分区中读取的，所以swap最大跟运存一样就可以了。

### 安全启动

**安全启动（Secure Boot）** 是 UEFI 固件中的一项 **安全功能**，目的是 **确保电脑在启动时只加载经过数字签名、受信任的操作系统引导程序和内核，防止恶意软件（如 rootkit、引导病毒）在系统启动的最早阶段加载和运行。**

它是在 **UEFI（统一可扩展固件接口，现代电脑的启动方式）** 环境下引入的，**传统 BIOS 模式下是没有“安全启动”这一说的**。

### zerotier

ZeroTier 是一种 **虚拟局域网（Virtual LAN, VLAN）/SD-WAN 软件**，它可以让分布在不同网络、不同地理位置的设备，像在同一个局域网里一样互相通信。你可以把它理解为一种结合了 **VPN（虚拟专用网络）** 和 **SDN（软件定义网络）** 的解决方案。在不同局域网下分配ip地址，即不同局域网下也能ping通。

https://cloud.tencent.com/developer/article/2390573**教程**

https://my.zerotier.com/network/0cccb752f771ed77**俺的网络**

linux下载：

```
curl -s https://install.zerotier.com | sudo bash
```

加入网络组：

```
sudo zerotier-cli join 0cccb752f771ed77
```

```
zerotier-cli status
```

初始连接需要联网搭桥

### 堆和栈

- **栈：**

  1. **定义：**

  **栈是一种 LIFO（后进先出，Last In First Out）结构的内存区域，由编译器自动管理，主要用于存储：**

  - **局部变量（函数内部定义的变量）**
  - **函数调用时的返回地址、参数、上下文信息等**

  2. **特点：**

  | 特性         | 说明                                                |
  | :----------- | :-------------------------------------------------- |
  | **管理方式** | 由 **编译器自动分配和释放**，程序员一般不用手动管理 |
  | **分配速度** | **非常快**（只是移动栈指针）                        |
  | **大小限制** | **较小**（通常几 MB，具体取决于系统和编译器）       |
  | **存储内容** | 局部变量、函数参数、返回地址、函数调用上下文等      |
  | **生命周期** | **随着函数调用开始而分配，函数返回时自动释放**      |
  | **内存结构** | **连续、有序，LIFO（后进先出）**                    |

  3. **例子：**

  ```
  void func() {
      int a = 10;       // a 是局部变量，存储在栈上
      int b = 20;       // b 也是栈上分配
      printf("%d\n", a + b);
  } // 函数结束，a 和 b 自动销毁（栈帧弹出）
  ```

- **堆：**

  1. **定义：**

  **堆是程序运行时由程序员（或运行时库）手动管理的一块** **动态内存区域**，用于存放：

  - **程序运行时动态分配的内存**
  - **大小不固定、生命周期不确定的数据，比如动态数组、结构体、对象等**

  2. **特点：**

  | 特性         | 说明                                                         |
  | :----------- | :----------------------------------------------------------- |
  | **管理方式** | **由程序员手动分配和释放（C 中用 malloc/free，C++ 中用 new/delete）**，若忘记释放会造成 **内存泄漏** |
  | **分配速度** | **相对较慢**（需要查找可用内存块，可能引发碎片）             |
  | **大小限制** | **较大**（受限于系统的可用内存，通常 GB 级别）               |
  | **存储内容** | 动态分配的数据，如 `malloc`分配的结构体、数组、对象等        |
  | **生命周期** | **由程序员控制，手动分配后需要手动释放，否则会一直占用内存（内存泄漏）** |
  | **内存结构** | **不连续、无固定顺序，需要程序员管理**                       |

  3. **例子：**

  ```
  int *arr = (int *)malloc(10 * sizeof(int));  // 在堆上动态分配内存
  if (arr == NULL) {
      perror("malloc failed");
      return;
  }
  // 使用 arr...
  arr[0] = 100;
  // 必须手动释放，否则内存泄漏
  free(arr);
  ```

### crc校验

**crc和fcs计算：**https://blog.csdn.net/weixin_63689762/article/details/146380410

**基本原理**：

1. 发送方对要发送的数据执行多项式除法（模 2 运算），得到一个余数（校验码）。
2. 把这个余数附在数据后面一并发送。
3. 接收方收到数据后，用相同的多项式再除一次，如果余数为 0，说明数据基本正确；否则表示有错误。

**发送数据时，根据原始数据计算出一个短的校验值（Checksum），并把这个校验值和数据一起发送；接收方收到数据后，也根据收到的数据计算一个 CRC 值，然后与发送方发来的校验值进行比对，如果一致，说明数据很可能没有出错，如果不一致，说明数据可能被篡改或传输中出现了错误。**

| CRC 类型   | 校验位数 | 常见用途 / 协议                                  |
| :--------- | :------- | :----------------------------------------------- |
| **CRC-8**  | 8 位     | 一些嵌入式设备、传感器通信                       |
| **CRC-16** | 16 位    | Modbus、USB、蓝牙、串口通信等                    |
| **CRC-32** | 32 位    | **以太网、ZIP、PNG、GZIP、RAR、TCP/IP 等最常用** |
| **CRC-64** | 64 位    | 一些高可靠性系统、文件系统等                     |

- **cpp的实现**

  ```
  #include <iostream>
  #include <vector>
  
  // 定义CRC-32的生成多项式
  const uint32_t POLYNOMIAL = 0x04C11DB7;
  
  // 计算单个字节的CRC值
  // data为输入待校验数据
  uint32_t crc32_byte(uint32_t data) {
  uint32_t crc = data << 24;
  for (int i = 0; i < 8; ++i) {
  if (crc & 0x80000000) {
  crc = (crc << 1) ^ POLYNOMIAL;
  //模二运算
  } else {
  crc <<= 1;
  }
  }
  return crc;
  }
  
  // 计算整个数据的CRC值
  uint32_t crc32(const std::vector<uint8_t>& data) {
  uint32_t crc = 0xFFFFFFFF;
  //表示data个位域
  for (uint8_t byte : data) {
  //左移位数
  crc ^= byte << 24;
  for (int i = 0; i < 8; ++i) {
  //与计算
  if (crc & 0x80000000) {
  //输出的crc进行再计算
  crc = (crc << 1) ^ POLYNOMIAL;
  } else {
  crc <<= 1;
  }
  }
  }
  return crc ^ 0xFFFFFFFF;
  }
  
  int main() {
  std::vector<uint8_t> data = {0x01, 0x02, 0x03, 0x04, 0x05};
  uint32_t crc = crc32(data);
  std::cout << "CRC-32: " << std::hex << crc << std::endl;
  return 0;
  }
  ```

输入输出进行反转->生成多项式为反向定位，同时由于移位寄存器的构造，反转后也更容易实现



# 编程相关 

你的程序崩溃并出现 **"核心已转储"（Core Dumped）**，通常是由于以下原因之一：

1. **线程创建时参数传递错误**（你的主要问题）
2. **线程访问了已释放的资源**
3. **空指针解引用**
4. **未捕获的异常导致线程终止**
5. **双重释放或内存越界**

如果你之前运行过同一个程序，**没有正常关闭 socket，或者程序异常退出，那么端口可能还在 `TIME_WAIT`状态（持续几分钟），导致你立即重启时绑定失败。**

## 套接字

**不看错过一个亿：**https://subingwen.cn/linux/socket/

- 数据协议socket：

  ![image-20250805101559158](主机.assets/image-20250805101559158.png)

  ✴socket包含信息：

  通信协议、本地协议地址、本地主机端口、远端主机端口、远端协议端口

- can：SocketCAN 是 Linux 内核原生支持的 CAN 总线接口，允许你像操作网络套接字一样操作 CAN 设备（如 `can0`）

  `can`：CAN 协议核心

  `can_raw`：提供原始 CAN 套接字

  `can_dev`：将 CAN 控制器和内核接口对接

  `mttcan`：针对 MTT CAN 控制器（比如 NXP S32K 系列或其他）的驱动

  ```
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>
  #include <net/if.h>
  #include <sys/ioctl.h>
  #include <sys/socket.h>
  #include <linux/can.h>
  #include <linux/can/raw.h>
  
  // 发送CAN数据函数
  void send_can_message(const char *ifname, int can_id, int is_extended, uint8_t *data, int dlc) {
      int s;
      struct sockaddr_can addr;
      struct ifreq ifr;
      struct can_frame frame;
  
      // 创建SocketCAN套接字（原始帧类型）
      if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
          perror("socket");
          exit(EXIT_FAILURE);
      }
  
      // 绑定到指定的CAN接口（如can0）
      strcpy(ifr.ifr_name, ifname);
      ioctl(s, SIOCGIFINDEX, &ifr);  // 获取接口索引
  
      addr.can_family = AF_CAN;
      addr.can_ifindex = ifr.ifr_ifindex;
  
      if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
          perror("bind");
          close(s);
          exit(EXIT_FAILURE);
      }
  
      // 填充CAN帧数据
      frame.can_id = can_id;
      if (is_extended) {
          frame.can_id |= CAN_EFF_FLAG;  // 设置扩展帧标志
      }
      frame.can_dlc = dlc;  // 数据长度（0~8字节）
      memcpy(frame.data, data, dlc);
  
      // 发送报文
      if (write(s, &frame, sizeof(struct can_frame)) != sizeof(struct can_frame)) {
          perror("write");
      } else {
          printf("Sent CAN frame: ID=0x%X (%s), DLC=%d, Data=", 
                 can_id, is_extended ? "EXT" : "STD", dlc);
          for (int i = 0; i < dlc; i++) {
              printf("%02X ", frame.data[i]);
          }
          printf("\n");
      }
  
      close(s);
  }
  
  int main() {
      // 示例：发送标准帧（ID=0x100，数据=0x01,0x02,0x03,0x04）
      uint8_t data_std[] = {0x01, 0x02, 0x03, 0x04};
      send_can_message("can0", 0x100, 0, data_std, 4);  // 0=标准帧
  
      // 示例：发送扩展帧（ID=0x12345678，数据=0xAA,0xBB）
      uint8_t data_ext[] = {0xAA, 0xBB};
      send_can_message("can0", 0x12345678, 1, data_ext, 2);  // 1=扩展帧
  
      return 0;
  }
  ```

## 多进程/多线程编译

本质为cpu内核在均分的极小时间片下进行快速调度，并且多线程的本质是抢占式、无序的，而线程的上下文切换比进程要快很多(储存上一次状态时，进程资源消耗更大)

**进程vs线程**

<img src="主机.assets/image-20250905200607929.png" alt="image-20250905200607929" style="zoom: 67%;" />

**使用场景：**多线程：多个并发任务；多进程：在程序A中使用程序B

<img src="主机.assets/image-20250905201420618.png" alt="image-20250905201420618" style="zoom:50%;" />

**虚拟地址的各个分区**

<img src="主机.assets/image-20250905200730968.png" alt="image-20250905200730968" style="zoom:50%;" />

### 进程

- 创建进程：

  ```
  #include <stdio.h>
  #include <unistd.h>
  
  int main() {
      pid_t pid = fork();
  
      if (pid == -1) {
          perror("fork failed");
          return 1;
      } else if (pid == 0) {
          // 子进程代码
          printf("This is the child process.\n");
      } else {
          // 父进程代码
          printf("This is the parent process. Child PID: %d\n", pid);
      }
  
      return 0;
  }
  ```

- 进程间通信（IPC）

  进程是独立的，不能直接共享内存，所以需要通过 IPC（Inter-Process Communication）进行通信。常见的 IPC 机制有：

  - **管道（Pipe）**：用于父子进程之间的单向通信。
  - **命名管道（FIFO）**：用于无关进程之间的单向通信。
  - **消息队列（Message Queue）**：用于进程间的消息传递。
  - **共享内存（Shared Memory）**：允许多个进程共享一块内存区域，实现高效的通信。
  - **信号量（Semaphore）**：用于进程间同步

  ```
  #include <sys/ipc.h>
  #include <sys/msg.h>
  #include <stdio.h>
  
  #define MSG_KEY 1234
  
  struct msg_buffer {
      long msg_type;
      char msg_text[100];
  };
  
  int main() {
      key_t key = MSG_KEY;
      int msgid = msgget(key, 0666 | IPC_CREAT);
  
      struct msg_buffer message;
      message.msg_type = 1;
      snprintf(message.msg_text, sizeof(message.msg_text), "Hello, from parent!");
  
      msgsnd(msgid, &message, sizeof(message.msg_text), 0);
  
      return 0;
  }
  ```

### 线程

**多线程：**https://zhuanlan.zhihu.com/p/93585010

**唤醒线程：**https://zhuanlan.zhihu.com/p/634385813

#### 基本函数

- 创建线程：

  ```
  int pthread_create(pthread_t *thread,const pthread_attr_t *attr.void *(*start_routine)(void *),void *arg);
  ```

  <img src="主机.assets/image-20250906083451686.png" alt="image-20250906083451686" style="zoom: 67%;" />

  ```
  #include <pthread.h>
  #include <stdio.h>
  
  //操作函数
  void *print_message(void *ptr) {
      printf("Thread: Hello, World!\n");
      return NULL; //注意返回类型
  }
  
  int main() {
      pthread_t thread_id; //线程id
      //创建并执行线程，返回标志位
      if (pthread_create(&thread_id, NULL, print_message, NULL)) {
          fprintf(stderr, "Error creating thread\n");
          return 1;
      }
  
      pthread_join(thread_id, NULL);  // 线程回收->仅回收一个线程
      return 0;
  }
  ```

  每个线程都有独立的线程id，并且在没有操作函数的情况下是无效的

  等待主线程的原因是多线程是抢占式的，这样让子线程抢到时间片，可以在主线程结束释放资源前执行。

  

  - **gcc编译命令**

    ```
    gcc pthread.c -lphread -o app
    /.app
    ```

  - **线程退出**

    **不释放主线程地址空间的线程退出**，因为子线程退出的内核资源主要由主线程回收。采用线程库中的线程退出函数

    ```
    void pthread_exit(void *retval); //参数为线程退出时令主线程携带的数据->等待回收状态
    ```


  - **回收线程**

    ```
     int pthread_join(pthread_t thread, void **retval);  // ->仅回收一个线程
    ```

    <img src="主机.assets/image-20250906083754298.png" alt="image-20250906083754298" style="zoom:67%;" />

    回收成功返回0,失败返回错误码

  由于子线程中变量申请的是虚拟堆栈，不能访问主线程中内核区的栈，所以如果需要在其他线程访问则需要设置全局变量，可以将内存申请在全局中，或者在主线程中把变量等于类指针后在子线程调用

  - **线程分离**

    避免主线程被join回收函数阻塞，当调用分离函数时子线程可以和主线程分离，子占用的内核资源被系统其他进程接管并回收 

    ```
    int pthread_detach(pthread_t thread);
    ```

  - **线程取消**

    <img src="主机.assets/image-20250906090535633.png" alt="image-20250906090535633" style="zoom:67%;" />

  ```
int pthread_cancel(pthread_t thread); //参数为要杀死的线程id
  ```

  即当线程b进行系统函数调用时则会被杀掉

  - **线程id比较**

    ```
    int pthread_equal(pthread_t t1,pthread_t t2);
    ```

- **线程同步**

  抢到时间片的线程的物理内存会被加载到gpu寄存器里

  ![image-20250906092755941](主机.assets/image-20250906092755941.png)

  在多线程编程中，同步机制是避免多个线程访问共享资源时发生数据冲突的关键。常见的同步机制有：

  - **互斥锁（mutex）**：用于保护共享资源，避免多个线程同时访问资源。
  - **条件变量（condition variable）**：线程之间用于协调执行顺序。
  - **信号量（semaphore）**：用于限制访问资源的线程数量。
  - **读写锁（read-write lock）**：适用于读多写少的场景，多个线程可以同时读取资源，但写线程需要独占资源。

#### 互斥锁

```
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t lock;

void *print_message(void *ptr) {
    pthread_mutex_lock(&lock);
    //尝试获取锁。如果锁已经被其他线程占用，当前线程将在此阻塞，直到锁可用
    printf("Thread: Critical section accessed\n");
    pthread_mutex_unlock(&lock);
    return NULL;
}

int main() {
    pthread_t thread_id;
    pthread_mutex_init(&lock, NULL);

    if (pthread_create(&thread_id, NULL, print_message, NULL)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    pthread_join(thread_id, NULL);  // 等待线程结束
    pthread_mutex_destroy(&lock);  // 销毁锁
    return 0;
}
```

线程开始添加->加锁后处于临界区(共享数据为临界资源也属于临界区)，线程只能按顺序串行执行

==哪个线程加的锁，哪个线程才能解锁==

1. ```
   pthread_mutex_t muitex; //声明变量
   int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr); 
   //初始化互斥锁，只有含restrict关键字的指针可以访问指向内存地址 
   
   int pthread_mutex_destroy(pthread_mutex_t *mutex);
   //摧毁互斥锁，释放资源
   
   int pthread_mutex_lock(pthread_mutex_t *mutex);
   int pthread_mutex_unlock(pthread_mutex_t *mutex);
   ```

2. ` std::lock_guard<std::mutex> lock(twist_mutex_);`                                                                                                                                                                                                                                                                                                         线程锁（`std::lock_guard<std::mutex> lock(twist_mutex_);`）是在作用域结束时自动解锁的。也就是说：

- 当 `twist_callback` 或 `periodic_twist_send` 函数执行到末尾，或者遇到 `return` 语句离开当前作用域时，`lock` 对象会被销毁，锁会自动释放。
- 你不需要手动解锁，`std::lock_guard` 会在其生命周期结束时自动调用 `mutex` 的 `unlock()`。

这种写法可以防止因为异常或提前返回导致忘记解锁，从而避免死锁问题。

-->**死锁问题**：在解锁前return导致解锁未被执行；重复加锁导致第二次锁函数堵塞->在加锁时可以trylock，当程序已经加锁时则等待

​	**特点：**

- **在构造时加锁，析构时自动解锁**
- **不能手动加锁或解锁**
- **不能延迟加锁**
- **不能复制或移动**
- **不能与 `std::condition_variable`一起使用**

 3. `std::uniquelock<std::mutex> lock(mutex);`

    **特点：**

    - **功能更丰富，更灵活**
    - **可以手动加锁和解锁**
    - **可以延迟加锁（构造时不加锁，后面再手动加）**
    - **可以移动（支持移动语义，但不能复制）**
    - **可以与 `std::condition_variable`配合使用（这是唯一推荐的方式）**
    - **有更多的构造选项，比如：`std::defer_lock`、`std::try_to_lock`**

#### 读写锁

读的时候可以并行操作，但有写操作时写优先



<img src="主机.assets/image-20250906143437248.png" alt="image-20250906143437248" style="zoom:67%;" />

```
pthread_rwlock_t rwlock; //声明变量
int pthread_rwlock_init(pthread_mutex_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr); 
//初始化读写锁，只有含restrict关键字的指针可以访问指向内存地址 

int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
//摧毁读写锁，释放资源

//对读写锁加读锁，锁定的是读操作
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
//避免死锁，不会阻塞当前线程
int pthread_rwlock_trywdlock(pthread_rwlock_t *rwlock);
//对读写锁加写锁，锁定的是写操作
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);

//解锁，不管是锁定了读还是写都可用解锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```

#### 条件变量

用于处理生产者和消费者模型，并且和互斥锁配合使用。

<img src="主机.assets/image-20250906164909030.png" alt="image-20250906164909030" style="zoom:67%;" />

**操作函数**

```
//定义变量
pthread_cond_t cond;

int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);
int pthread_cond_destroy(pthread_cond_t *cond);

//线程阻塞函数,当解除阻塞时这个线程会再次上锁
int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);
```

<img src="主机.assets/image-20250906165950957.png" alt="image-20250906165950957" style="zoom:67%;" />

​	唤醒阻塞线程：

<img src="主机.assets/image-20250906165834063.png" alt="image-20250906165834063" style="zoom:67%;" />

####  **生产者与消费者模型**

当生产者生产出节点后唤醒消费者，消费者在判断接收的节点为空则阻塞，不为空则正常运行

```
#include <iostream>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <random>

// 缓冲区最大容量
const int MAX_SIZE = 5;

// 共享数据
std::queue<int> buffer;             // 缓冲队列
std::mutex mtx;                     // 互斥锁，保护对 buffer 的访问
std::condition_variable not_full;   // 条件变量：队列不满时唤醒生产者
std::condition_variable not_empty;  // 条件变量：队列不空时唤醒消费者

// 生产者函数
void producer(int id) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 100);

    for (int i = 0; i < 10; ++i) {  // 生产 10 个数据
        std::unique_lock<std::mutex> lock(mtx);

        // 如果队列满了，等待 "not_full" 信号
        not_full.wait(lock, [] { return buffer.size() < MAX_SIZE; });

        // 生产数据：生成随机数并放入队列
        int num = dis(gen);
        buffer.push(num);
        std::cout << "生产者 " << id << " 生产了: " << num 
                  << "，队列大小: " << buffer.size() << std::endl;

        lock.unlock();     // 解锁（其实 unique_lock 析构时也会解锁，但显式更清晰）
        not_empty.notify_one();  // 通知消费者：队列非空了

        // 模拟生产耗时
        std::this_thread::sleep_for(std::chrono::milliseconds(dis(gen) % 300 + 100));
    }
}

// 消费者函数
void consumer(int id) {
    for (int i = 0; i < 10; ++i) {  // 消费 10 个数据
        std::unique_lock<std::mutex> lock(mtx);

        // 如果队列为空，等待 "not_empty" 信号
        not_empty.wait(lock, [] { return !buffer.empty(); });

        // 消费数据：从队列头部取出
        int num = buffer.front();
        buffer.pop();
        std::cout << "消费者 " << id << " 消费了: " << num 
                  << "，队列大小: " << buffer.size() << std::endl;

        lock.unlock();
        not_full.notify_one();  // 通知生产者：队列不满了

        // 模拟消费耗时
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
}

int main() {
    // 创建 2 个生产者线程 和 2 个消费者线程
    std::thread producers[2] = {
        std::thread(producer, 1),
        std::thread(producer, 2)
    };

    std::thread consumers[2] = {
        std::thread(consumer, 1),
        std::thread(consumer, 2)
    };

    // 等待所有生产者完成
    for (auto& p : producers) p.join();

    // 等待所有消费者完成
    for (auto& c : consumers) c.join();

    std::cout << "所有生产消费任务完成！" << std::endl;
    return 0;
}
```

#### 信号量

**信号量（Semaphore）** 是一种用于 **多线程 / 多进程同步与互斥的机制**，它本质上是一个 **计数器 + 等待队列**，用于控制对共享资源的访问，尤其适用于 **限制同时访问某一资源的线程数量**。

主要用于阻塞线程。不能保证线程安全，要保证安全的话要与互斥锁一起用；在相同队列中，消费者和生产者的资源数量是不同的，而资源的动态变化就用信号量表示

**操作函数**

```
#include <semaphore.h>
sem_t sem;

int sem_init(sem_t *sem,int pshared,unsigned int value);
int sem_destroy(sem_t *sem);

int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
```

<img src="主机.assets/image-20250906173123324.png" alt="image-20250906173123324" style="zoom: 67%;" />

休眠函数：

<img src="主机.assets/image-20250906173506375.png" alt="image-20250906173506375" style="zoom: 67%;" />

<img src="主机.assets/image-20250906173647066.png" alt="image-20250906173647066" style="zoom:67%;" />

1. **控制并发访问资源的线程数量**

- **最多允许 N 个线程同时访问某个资源（如数据库连接池、文件、硬件设备等）**
- 信号量的初始值 = **最大允许并发数 N**

2. **线程间同步**

- **线程 A 必须等线程 B 完成某个动作后才能继续**（通过信号量协调顺序）

3. **替代简单的互斥锁（但更通用）**

- 信号量当计数器为 **1 时，功能类似互斥锁（mutex）**，但信号量更灵活，可以允许多个线程同时访问。

**生产者和消费者模型**

区别于条件变量：在信号量的调度中，资源量有限，不会出现多个消费者抢占的情况，两个对象关于资源的操作是有来有回的。

<img src="主机.assets/image-20251019170845484.png" alt="image-20251019170845484" style="zoom:67%;" />

##### 三种通知机制对比

| **特性**             | **条件变量 (`std::condition_variable`)** | **`std::promise`/`std::future`** | **信号量 (`std::counting_semaphore`)**   |
| :------------------- | :--------------------------------------- | :------------------------------- | :--------------------------------------- |
| **用途**             | 线程间条件等待（需搭配互斥锁）           | 一次性事件通知（异步结果传递）   | 资源计数（限制并发访问数）               |
| **等待/通知机制**    | 需显式调用 `wait()`和 `notify_one/all()` | 通过 `future.get()`阻塞等待结果  | 通过 `acquire()`/`release()`控制资源访问 |
| **是否支持多次通知** | 是（可重复触发条件）                     | 否（只能设置一次结果）           | 是（可多次增减信号量计数）               |
| **底层实现**         | 基于锁和系统级线程唤醒                   | 基于原子操作和系统级事件         | 基于原子计数和轻量级阻塞                 |
| **C++标准版本**      | C++11                                    | C++11                            | C++20（需编译器支持）                    |
| **适用场景**         | 复杂条件等待（如生产者-消费者）          | 异步任务结果传递                 | 限制并发线程数或资源访问                 |

信号量：https://blog.csdn.net/J080624/article/details/85625350

##### 原子变量和普通变量

| **特性**         | **原子变量（如 `std::atomic<int>`）** | **普通变量（如 `int`）**     |
| :--------------- | :------------------------------------ | :--------------------------- |
| **线程安全**     | 是（硬件/编译器保证）                 | 否（需手动加锁）             |
| **操作的原子性** | 单条指令完成（不可中断）              | 可能被线程调度打断（非原子） |
| **性能开销**     | 低（无锁设计）                        | 高（需互斥锁 `std::mutex`）  |
| **内存顺序控制** | 支持（如 `memory_order_relaxed`）     | 不支持                       |
| **适用场景**     | 计数器、标志位等简单操作              | 复杂数据结构（需锁保护）     |

### 线程池

- 线程组成：管理器，任务队列(储存多个任务线程)，工作线程(有且仅有一个，其他都是取出来使用的)，同步机制

- 注意事项：对于线程池的管理应该是动态分布内存的，队列的话可以优先级顺序也可以fifo按提交顺序，同步机制就是互斥锁和防止资源冲突的原子操作，防止线程冲突的条件变量；以及线程的异常处理，避免因为异常退出或阻塞造成瘫痪->当一个线程执行，其他线程为阻塞状态

  ->消费者生产者模型实现：设置条件变量和队列，生产者向队列添加，改变条件变量，消费者从队列取出。

- 代码实现：

  1. 定义线程池的类

     ```
     class ThraedPool
     {
     public:
         ThraedPool(int min = 2, int max = thread::hardware_concurrency());
         ~ThraedPool();
     
         // 添加任务->任务队列
         void addTask(function<void(void)> task);
     
     private:
         void manager(void);
         void worker(void);
         
     private:
         thread* m_manager;
         vector<thread> m_workers;
         atomic<int> m_minThread;
         atomic<int> m_maxThread;
         atomic<int> m_curThread;
         atomic<int> m_idleThread;
         atomic<int> m_exitThread;
         atomic<bool> m_stop;
         queue<function<void(void)>> m_tasks;
         mutex m_queueMutex;
         condition_variable m_condition;
     };
     ```

  2. 利用容器储存线程，原子变量安全(#include "atomic")

  3. 构成：

     1. 管理者线程->1个子线程：控制工作线程的数量，增加或减少
     2. 若干工作线程->N个子线程：从任务队列中取线程，并处理；队列为空，则被条件变量阻塞；并用互斥锁进行线程同步；当前和空闲的线程数量进行动态管理；设置最小和最大的线程数量
     3. 任务队列->stl->queue，用互斥量和条件变量控制
     4. 线程池开关->bool

  - operator:将变量做强制零转换，为一个函数指针

  - 初始化的效率比赋值更高

  - notify_one():唤醒线程，唤醒后线程会抢锁

  - move(m_tasks.front()):将取出对象存入task任务中，这样数据转移的方式占用的cpu资源比直接数据资源拷贝更少

    ```
    void ThraedPool::worker(void)
    {
        while (!m_stop.load())
        {
            function<void(void)> task = nullptr;
            unique_lock<mutex> locker(m_queueMutex);
            while (m_tasks.empty() && m_stop)
            {
            //确认队列不为空
                m_condition.wait(lock);
                //检测退出线程
                if (m_exitThread.load() > 0)
    {
        m_curThread--;
        m_exitThread--;
        cout << "---------- 线程退出了，ID：" << this_thread::get_id() << endl;
        return;
    }
            }
            if (!m_tasks.empty())
            {
                task = move(m_tasks.front());
                m_tasks.pop();
            }
            if (task)
            {
                m_idleThread--;
                task();
                m_idleThread++;
            }
        }
    }
    ```

  4.管理者线程不断重复执行：将它作为一个简单的检测定时器

  ```
  void ThraedPool::manager(void)
  {
      while (!m_stop.load())
      {
          this_thread::sleep_for(chrono::seconds(3));
          int idel = m_idleThread.load();
          int cur = m_curThread.load();
          if (idel > cur / 2 && cur > m_minThread)
          {
              //每次销毁两个线程
              m_exitThread.store(2);
              m_condition.notify_all();
          }
          else if (idel == 0 && cur < m_maxThread)
          {
              m_workers.emplace_back(thread(&ThraedPool::worker, this));
              m_curThread++;
              m_idleThread++;
          }
      }
  }
  ```

<img src="主机.assets/image-20251007171601627.png" alt="image-20251007171601627" style="zoom:50%;" />

- 主函数创建任务：当函数带有参数时，需要用bind函数先进行将参数绑定到函数，再传入创建
- getchar():获取键盘的任何输入，阻塞式

```
#include <iostream>
#include <thread>
#include <vector>
#include <functional>
#include <queue>
#include <condition_variable>
#include <atomic>

class ThreadPool {
public:
    ThreadPool(size_t threads) : stop(false) {
        for (size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(this->queue_mutex);
                        this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });
                        if (this->stop && this->tasks.empty())
                            return;
                        task = std::move(this->tasks.front());
                        this->tasks.pop();
                    }
                    task();
                }
            });
        }
    }

    template<class F>
    void enqueue(F&& f) {
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            tasks.push(std::function<void()>(f));
        }
        condition.notify_one();
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread& worker : workers) {
            worker.join();
        }
    }

private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;
};

int main() {
    ThreadPool pool(4);  // 创建一个包含 4 个线程的线程池

    // 提交任务到线程池
    for (int i = 0; i < 10; ++i) {
        pool.enqueue([i] {
            std::cout << "Task " << i << " is running in thread " << std::this_thread::get_id() << std::endl;
        });
    }

    return 0;
}
```

- memcpy:用于将一块内存区域的数据（字节级别）复制到另一块内存区域

- 事件驱动模型：指通过事件循环和回调机制来管理并发任务。在事件驱动模型中，系统通过监听各种事件（如用户输入、网络请求、定时器触发等），并通过回调函数处理这些事件。

## I/O多路复用

核心目标：**用最小资源开销实现高并发I/O处理**，尤其适用于需要同时处理大量连接的场景

在平常的并行服务中，文件描述符返回任意错误码(accept,write,read)，则线程阻塞住无法执行任何操作，读写分别有不同的内核缓冲区，accept用于检测内核区可操作，返回事件(文件描述符)

<img src="主机.assets/image-20250906181918184.png" alt="image-20250906181918184" style="zoom: 50%;" />

->意义：

**I/O 多路复用的核心任务：监听多个 fd 的 I/O 事件**

在传统的一对一阻塞 I/O 模型中：

- 每个 socket 连接都要用一个线程去等待数据到来（阻塞在 `read()`或 `accept()`上）
- 如果有 1000 个客户端，就需要 1000 个线程，资源消耗巨大

而在 **I/O 多路复用模型（比如 select / poll / epoll）** 中：

- 你只需要 **一个线程**
- 通过 **一个系统调用（如 epoll_wait）**
- 就可以 **同时监听成百上千个 fd（比如 socket）**
- 当其中 **某个 fd 发生了 I/O 事件（比如有数据可读）**，系统就会通知你，你再去处理那个 fd

### select篇 

#### **操作函数**

```
#include <sys/select.h>
struct timeval {
    time_t      tv_sec;         /* seconds */
    suseconds_t tv_usec;        /* microseconds */ 必须初始化不然是随机数
};
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval * timeout);
```

如果没有检测到符合要求的文件描述符，则函数直接返回

<img src="主机.assets/image-20250906193607223.png" alt="image-20250906193607223" style="zoom: 50%;" />

#### **文件描述符**

fd_set参数相关操作函数：

```
// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0
void FD_CLR(int fd, fd_set *set);
// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1
int FD_ISSET(int fd, fd_set *set);
// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1
void FD_SET(int fd, fd_set *set);
// 将set集合中，所有文件文件描述符对应的标志位设置为0，集合中没有添加任何文件描述符
void FD_ZERO(fd_set *set);
```

函数将相关读写或者异常集合传递给内核，内核根据集合进行检测，而返回值即符合条件的文件描述符的个数

<img src="主机.assets/image-20250906194202291.png" alt="image-20250906194202291" style="zoom:50%;" />

->为什么分普通fd和最大fd？

**fd_set 是一个位图（bit array），每一位代表一个文件描述符是否被监听。**比如 `fd = 3`，就对应位图中的第 3 位。

**select 会从 fd = 0 开始，一直到 fd = nfds - 1，逐个检查这些 fd 是否在你的 readfds/writefds/exceptfds 中被设置了，并且是否就绪。**

#### **服务器端并发**

 select套接字操作流程，单函数只是检测一轮，而后面的判断生效要等下一次内核检测集合 ：

1. 创建监听的套接字 lfd = socket()；

2. 将监听的套接字和本地的 IP 和端口绑定 bind()

3. 给监听的套接字设置监听 listen()

4. 创建一个文件描述符集合 fd_set，用于存储需要检测读事件的所有的文件描述符。 通过 FD_ZERO() 初始化 通过 FD_SET() 将监听的文件描述符放入检测的读集合中

5. 循环调用 select()，周期性的对所有的文件描述符进行检测(此时将fd_set重置初始化)

6. select() 解除阻塞返回，得到内核传出的满足条件的就绪的文件描述符集合 通 过 FD_ISSET() 判断集合中的标志位是否为 1 如果这个文件描述符是监听的文件描述符，调用 accept() 和客户端建立连接 将得到的新的通信的文件描述符，通过 FD_SET() 放入到检测集合中 如果这个文件描述符是通信的文件描述符，调用通信函数和客户端通信 如果客户端和服务器断开了连接，使用 FD_CLR() 将这个文件描述符从检测集合中删除 如果没有断开连接，正常通信即可

   <img src="主机.assets/image-20250906203107080.png" alt="image-20250906203107080" style="zoom:50%;" />

**多线程并发**

并行处理客户端需求，当主线程将内存指针(文字描述符)传递给子线程时，要在子线程中释放堆内存；

关于文字描述符是否要加保护锁：其为数据拷贝，并不涉及共享资源

当接收一次信息创建一个线程，但线程被创建后不一定能抢到时间片

### poll篇

<img src="主机.assets/image-20250906213834822.png" alt="image-20250906213834822" style="zoom: 67%;" />

#### 操作函数

```
#include <poll.h>
// 每个委托poll检测的fd都对应这样一个结构体
struct pollfd {
    int fd;        /* 委托内核检测的文件描述符 */
    short events;  /* 委托内核检测文件描述符的什么事件 */
    short revents; /* 文件描述符实际发生的事件 -> 传出 */
};

struct pollfd myfd[100];
int poll(struct pollfd *fds, nfds_t nfds, int timeout); //若干个文字描述符构成结构体
```

<img src="主机.assets/image-20250906214541215.png" alt="image-20250906214541215" style="zoom:67%;" />

#### 并发编程

编程方式与select套接字编程类似，只是用的函数不同

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <poll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MAX_CLIENTS 10
#define PORT 8888
#define BUFFER_SIZE 1024

int main() {
    int lfd, cfd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len = sizeof(client_addr);

    char buffer[BUFFER_SIZE];

    // 1. 创建监听 socket
    lfd = socket(AF_INET, SOCK_STREAM, 0);
    if (lfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. 绑定
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(lfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(lfd);
        exit(EXIT_FAILURE);
    }

    // 3. 监听
    if (listen(lfd, 5) == -1) {
        perror("listen");
        close(lfd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    // 4. 初始化 pollfd 数组
    struct pollfd fds[MAX_CLIENTS + 1];  // +1 是为了监听 fd（lfd）
    int nfds = 0;  // 当前实际监听的 fd 数量

    // 5. 将监听 socket 加入 poll 数组
    fds[nfds].fd = lfd;
    fds[nfds].events = POLLIN;  // 监听可读事件（有新连接）
    nfds++;

    // 6. 循环调用 poll()
    while (1) {
        int ret = poll(fds, nfds, -1);  // 阻塞等待，直到有事件发生
        if (ret == -1) {
            perror("poll");
            break;
        }

        // 7. 遍历所有 fd，查看哪个 fd 有事件发生
        for (int i = 0; i < nfds; i++) {
            if (fds[i].revents & POLLIN) {
                if (fds[i].fd == lfd) {
                    // 7.1 如果是监听 socket，说明有新连接
                    cfd = accept(lfd, (struct sockaddr *)&client_addr, &client_len);
                    if (cfd == -1) {
                        perror("accept");
                        continue;
                    }

                    printf("New client connected: %s:%d\n",
                           inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

                    // 7.2 将新连接的客户端 socket 加入 poll 数组
                    if (nfds < MAX_CLIENTS + 1) {
                        fds[nfds].fd = cfd;
                        fds[nfds].events = POLLIN;  // 监听可读
                        nfds++;
                    } else {
                        printf("Too many clients!\n");
                        close(cfd);
                    }
                } else {
                    // 7.3 如果是客户端 socket，说明有数据可读
                    cfd = fds[i].fd;
                    memset(buffer, 0, BUFFER_SIZE);
                    int len = recv(cfd, buffer, BUFFER_SIZE, 0);
                    if (len <= 0) {
                        // 客户端断开连接
                        if (len == 0) {
                            printf("Client disconnected: fd=%d\n", cfd);
                        } else {
                            perror("recv");
                        }
                        close(cfd);
                        // 从 poll 数组中移除该 fd（用最后一个覆盖当前，然后减少 nfds）
                        fds[i] = fds[nfds - 1];
                        nfds--;
                        i--;  // 因为当前位置被替换，需要重新判断
                    } else {
                        // 打印客户端发来的数据
                        printf("Received from client fd=%d: %s\n", cfd, buffer);
                        // 可以在这里回复客户端
                        send(cfd, buffer, len, 0);
                    }
                }
            }
        }
    }

    // 8. 关闭监听 socket（实际上不会执行到这里）
    close(lfd);
    return 0;
}
```

### epoll篇

#### 概念与select、poll的区别

epoll 全称 eventpoll，是 linux 内核实现 IO 多路转接/复用（IO multiplexing）的一个实现。IO 多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll 是 select 和 poll 的升级版，相较于这两个前辈，epoll 改进了工作方式，因此它更加高效。虽然高效，但不能跨平台使用

- 对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。
- select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降
- select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。
- 程序猿需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测
- 使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制

<img src="主机.assets/image-20250907211202177.png" alt="image-20250907211202177" style="zoom: 50%;" />

->文件描述符监听方式区别及红黑树的概念

**红黑树（Red-Black Tree）** 是 **epoll 实例内部用于高效管理被监听的文件描述符（fd）的数据结构**

| 机制       | 数据结构                 | 查找/管理 fd 效率                        | 最大 fd 数量     | 适用场景                   |
| :--------- | :----------------------- | :--------------------------------------- | :--------------- | :------------------------- |
| **select** | 位图（bitmap），固定数组 | O(n)，效率低                             | 有限（如 1024）  | 少量连接，兼容性好         |
| **poll**   | 链表                     | O(n)，线性查找                           | 较大，但仍是线性 | 比 select 灵活，但性能仍差 |
| **epoll**  | **红黑树 + 就绪链表**    | **O(log n) 插入/删除，O(1) 获取就绪 fd** | 几十万甚至更高   | 高并发，高性能网络服务     |

#### 操作函数

```
#include <sys/epoll.h>
// 创建epoll实例,通过一棵红黑树管理待检测集合
int epoll_create(int size);
// 管理红黑树上的文件描述符(添加、修改、删除)
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// 检测epoll树中是否有就绪的文件描述符
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
int epoll_pwait(int epfd, struct epoll_event events, int maxevents, int timeout, const sigset_t sigmask);
```

创建堆内存后，由第一个指针指向内存供epoll使用

<img src="主机.assets/image-20250907214943067.png" alt="image-20250907214943067" style="zoom: 50%;" />

并发编程步骤

1.**创建监听的套接字**

```
int lfd = socket(AF_INET, SOCK_STREAM, 0);
```

2.设置端口复用 (可选)

```
int opt = 1;
setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
```

3.**使用本地的IP与端口和监听的套接字进行绑定**

```
int ret = bind(lfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
```

4.**给监听的套接字设置监听**

```
listen(lfd, 128);
```

5.**创建epoll实例对象**

```
int epfd = epoll_create(100);
```

6.**将用于监听的套接字添加到epoll实例中**

```
struct epoll_event ev;
ev.events = EPOLLIN; // 检测lfd读缓冲区是否有数据
ev.data.fd = lfd;
int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
```

7.**检测添加到epoll实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理**

```
int num = epoll_wait(epfd, evs, size, -1);
```

  **如果是监听的文件描述符，和新客户端建立连接，将得到的文件描述符添加到epoll实例中**

```
int cfd = accept(curfd, NULL, NULL);
ev.events = EPOLLIN;
ev.data.fd = cfd;
// 新得到的文件描述符添加到epoll模型中，下一轮循环的时候就可以被检测了
epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);
```

  **如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从epoll实例中删除**

```
int len = recv(curfd, buf, sizeof(buf), 0);
if(len == 0)
{
    // 将这个文件描述符从epoll模型中删除
    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL);
    close(curfd);
}
else if(len > 0)
{
    send(curfd, buf, len, 0);
}
```

<img src="主机.assets/image-20250908222134141.png" alt="image-20250908222134141" style="zoom:50%;" />

#### **工作模式**

- 水平模式：水平模式可以简称为 LT 模式，LT (level triggered) 是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核通知使用者哪些**文件描述符已经就绪**，之后就可以对这些已就绪的文件描述符进行 IO 操作了。如果我们不作任何操作，内核还是会**继续通知**使用者。因此会存在资源消耗。

  <img src="主机.assets/image-20250909082107321.png" alt="image-20250909082107321" style="zoom: 50%;" />



<img src="主机.assets/image-20250909082611566.png" alt="image-20250909082611566" style="zoom: 25%;" />

- 边沿模式：边沿模式可以简称为 ET 模式，ET (edge-triggered) 是高速工作方式，只支持 no - block socket 。在这种模式下，当文件描述符从未就绪变为就绪时，内核会通过 epoll 通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知 (only once) 。如果我们对这个文件描述符做 IO 操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。但由特点可发现即使当缓冲区未读完，一旦进行io操作便变为未就绪状态，只能等下次服务器发送消息时接收未接受完的数据。

  <img src="主机.assets/image-20250909083007527.png" alt="image-20250909083007527" style="zoom:50%;" />

  ET模式的设置：边沿模式不是默认的 epoll 模式，需要额外进行设置。epoll 设置边沿模式是非常简单的，epoll 管理的红黑树示例中每个节点都是 struct epoll_event 类型，只需要将 EPOLLET 添加到结构体的 events 成员中即可

  ```
  //将监听文字描述符改为边沿模式
  ev.events = EPOLLIN | EPOLLET;
  ev.data/fd = lfd;
  ```

  关于就绪态的问题解决方式是可以循环发送read函数。但io处理的过程是阻塞的，当循环次数超出需要时，会出现线程阻塞，而io复用是在单线程中，所以应想办法吧rev函数设为非阻塞。方法是改变描述符属性。

  ```
  // 设置完成之后, 读写都变成了非阻塞模式
  int flag = fcntl(cfd, F_GETFL); //获取描述符属性
  flag |= O_NONBLOCK; //设置为非阻塞
  fcntl(cfd, F_SETFL, flag); //保存描述符属性
  ```

  阻塞问题解决后，还要解决循环何时退出的问题；可以通过recv返回的错误符为标识符。

  ```
  if(error == EAGAIN)
  {
      printf("数据已经接收完毕...\n");
      break;
  }
  else
  {
      perror("recv error");
      exit(1);
  }
  ```

->**`strncat`是 C 标准库中的一个字符串处理函数，用于** **将一个字符串的前 n 个字符追加（连接）到另一个字符串的末尾**，并在连接后的字符串末尾**自动添加 '\0'（空字符）作为结束符**

->线程安全操作可以不考虑加锁

**关于epoll的简单实现：**https://zhuanlan.zhihu.com/p/470304305

->**当多个客户端都有数据可读时会发生什么？**

- `epoll_wait()`会返回 **多个事件**，比如 3 个客户端 socket 同时有数据到达，它可能返回 3 个 `epoll_event`，每个对应一个可读的 fd；
- 每个 `events[i]`中的 `events[i].data.fd`是那个 socket 的文件描述符；
- 每个 `events[i].events`中包含 `EPOLLIN`，表示该 socket 可读；

->**有了epoll为什么还要用多线程？**

有时候连接了客户端不是简单的接收数据，可能还涉及复杂的图像处理和数据处理等等，这些任务可以开多线程提高解决效率。

## QT通信

### 传输层通信协议

tcp相对稳定，具体可以去看网络安全的笔记，流程如下：

<img src="主机.assets/image-20250909093403473.png" alt="image-20250909093403473" style="zoom: 50%;" />

udp通信与tcp通信流程大致一致，并没有严格意义上的服务端和客户端，流程如下：

<img src="主机.assets/image-20250909093203860.png" alt="image-20250909093203860" style="zoom:50%;" />

### 概念和常用API

qt是一个c++的框架，提供了用于套接字通信的类

#### **网络模块**QTcpserver

<img src="主机.assets/image-20250909094116487.png" alt="image-20250909094116487" style="zoom:50%;" />

```
//构造函数
QTcpServer::QTcpServer(QObject *parent = Q_NULLPTR);
//给监听的套接字设置监听，端口必须指定，若为0则绑定随机端口，客户端的端口选择就会很麻烦，选择时尽量选择5000以上未被系统占用
bool QTcpServer::listen(const QHostAddress &address = QHostAddress::Any, quint16 port = 0);
// 判断当前对象是否在监听, 是返回true, 没有监听返回false
bool QTcpServer::isListening() const;
// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::Null
QHostAddress QTcpServer::serverAddress() const;
// 如果服务器正在侦听连接, 则返回服务器的端口; 否则返回0
quint16 QTcpServer::serverPort() const
```

->父类vs父对象：前者有继承关系，后者没有；**父对象**的意义是当其析构时**子对象也会跟着析构**，从而避免内存释放的问题

参数:

-  address: 通过类QHostAddress可以封装IPv4、IPv6格式的IP地址，QHostAddress::Any表示自动绑定
-  port: 如果指定为0表示随机绑定一个可用端口。

得到和客户端建立连接之后用于通信的 QTcpSocket 套接字对象, 它是 QTcpServer 的一个子对象, 当 QTcpServer 对象析构的时候会自动析构这个子对象, 当然也可自己手动析构, 建议用完之后自己手动析构这个通信的 QTcpSocket 对象。

```
 QTcpSocket *QTcpServer::nextPendingConnection();
```

阻塞等待客户端发起的连接请求, 不推荐在单线程程序中使用, 建议使用非阻塞方式处理新连接, 即使用信号 newConnection()。

```
 bool QTcpServer::waitForNewConnection(int msec = 0, bool *timedOut = Q_NULLPTR);
```

参数:
 msec: 指定阻塞的最大时长, 单位为毫秒 (ms)
 timeout: 传出参数, 如果操作超时 timeout 为 true, 没有超时 timeout 为 false

**信号：**

当接受新连接导致错误时，将发射如下信号。socketError 参数描述了发生的错误相关的信息。

```
void QTcpServer::acceptError(QAbstractSocket::SocketError socketError);
```

每次有新连接可用时都会发出 newConnection()信号。

```
void QTcpServer::newConnection();
```

####  套接字模块QTcpSocket

是一个套接字通信类，客户端和服务端都需要使用，在QT中发送和接收也属于IO操作(网络IO)

<img src="主机.assets/image-20250910201238990.png" alt="image-20250910201238990" style="zoom: 50%;" />

构造函数

```
 QTcpSocket::QTcpSocket(QObject *parent = Q_NULLPTR);
```

连接服务器，需要指定服务器端绑定的IP和端口信息。

```
 [virtual] void QAbstractSocket::connectToHost(const QString &hostName, quint16 port, OpenMode openMode = ReadWrite,NetworkLayerProtocol protocol = AnyIPProtocol);
 [virtual] void QAbstractSocket::connectToHost(const QHostAddress &address, quint16 port, OpenMode openmode = ReadWrite);
```

在 Qt 中不管调用读操作函数接收数据，还是调用写函数发送数据，操作的对象都是本地的由 Qt 框架维护的一块内存。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，关于底层的相关操作是不需要使用者来维护的。

接收数据

在使用 QTcpSocket 进行套接字通信的过程中,如果该类对象发射出 readyRead() 信号,说明对端发送的数据达到了,之后就可以调用 read 函数 接收数据了。

```
[signal] void QIODevice::readyRead();
```

调用 connectToHost() 函数并成功建立连接之后发出 connected() 信号。

```
[signal] void QAbstractSocket::connected();
```

在套接字断开连接时发出 disconnected() 信号。

```
[signal] void QAbstractSocket::disconnected();//客户端和服务端都可以用
```

==**套接字命令操作的不是网络中的数据而是本地中的数据**==，即qt帮助维护的内存区

### 通信流程

#### 服务器端

1. 创建套接字服务器 `QTcpServer` 对象
2. 通过 `QTcpServer` 对象设置监听，即：`QTcpServer::listen()`
3. 基于 `QTcpServer::newConnection()` 信号检测是否有新的客户端连接
4. 如果有新的客户端连接调用 `QTcpSocket *QTcpServer::nextPendingConnection()` 得到通信的套接字对象
5. 使用通信的套接字对象 `QTcpSocket` 和客户端进行通信

#### 客户端

1. 创建通信的套接字类 QTcpSocket 对象
2. 使用服务器端绑定的 IP 和端口连接服务器 `QAbstractSocket::connectToHost()`
3. 使用 QTcpSocket 对象和服务器进行通信

### 通信实例

**qt窗口的mainwindows和widget的区别？**

| **特性**          | **QMainWindow**                 | **QWidget**                  |
| :---------------- | :------------------------------ | :--------------------------- |
| **定位**          | 主窗口（带完整框架结构）        | 通用基础窗口或部件容器       |
| **菜单栏/工具栏** | 内置支持                        | 需手动实现                   |
| **状态栏**        | 内置支持                        | 需手动实现                   |
| **中心部件**      | 必须设置一个中心部件            | 无强制要求                   |
| **Dock窗口**      | 支持停靠窗口                    | 不支持                       |
| **适用场景**      | 应用程序主窗口（如IDE、编辑器） | 对话框、子窗口、自定义小部件 |
| **继承关系**      | 继承自 `QWidget`                | Qt所有可视部件的基类         |

#### 窗口搭建

widget->pushbotton->label->水平->widget->groupbox->textedit->竖直->widget->pushbotton->horizontal spacer->竖直

#### 通信处理

- 加载模块

  ![image-20250911170857887](主机.assets/image-20250911170857887.png)

- 在mainwindow.cpp中包含头文件

- 创建参数，可以通过程序创建也可以在pushbotton右键转到槽，通过向导得到变量

  - 明确控件类型和object name,它们的可操作函数不一样

#### 状态栏处理

- 创建src
- 前辍改为/，越短越好
- 导入图片文件，在代码中调用

->在项目中，如果qt将文件都当作普通文件读取了，可以在页面上栏中选择**构建**，点击**构建套件**

#### 多线程

- 通过**Qthread**创建父类

  这种在程序中添加子线程的方式是非常简单的，但是也有弊端，假设要在一个子线程中处理多个任务，所有的处理逻辑都需要写到run()函数中，这样该函数中的处理逻辑就会变得非常混乱，不太容易维护。

  1. 需要创建一个线程类的子类，让其继承 QT 中的线程类 QThread，比如：

     ```
     class MyThread:public QThread{};
     ```

  2. 重写父类的 run() 方法，在该函数内部编写子线程要处理的具体的业务流程

     ```
     class MyThread:public QThread
      {
      protected:
      void run() {
      ........  // 在这里编写子线程的业务逻辑
      }
      };
     ```

  3. 在主线程中创建子线程对象，new 一个就可以了

     ```
     MyThread *subThread = new MyThread;
     ```

  4. 启动子线程，调用 start() 方法

     ```
     subThread->start();
     ```

      注意：

  - 不能在类的外部调用 run() 方法启动子线程，在外部调用 start() 相当于让 run() 开始运行

  - 当子线程被创建出来之后，父子线程之间的通信可以通过信号槽的方式

  - 在 Qt 中在子线程中不要操作程序中的窗口类型对象，不允许，如果操作了程序就挂了

  - 只有主线程才能操作程序中的窗口对象，默认的线程就是主线程，自己创建的就是子线程

    

- **QObject**工作类派生

  1.创建一个新的类，让这个类从QObject派生

  ```
   class MyWork:public QObject { ...... }
  ```

   2.在这个类中添加一个公共的成员函数，函数体就是我们要子线程中执行的业务逻辑

  ```
   class MyWork:public QObject { ......
   public:
   	void working();
   }
  ```

   3.在主线程中创建一个QThread对象, 这就是子线程的对象

  ```
   QThread* sub = new QThread;
  ```

   4.在主线程中创建工作的类对象 (千万不要指定给创建的对象指定父对象)

  ```
   MyWork* work = new MyWork; // ok
   MyWork* work = new MyWork(this); // error
  ```

   5.将MyWork对象移动到创建的子线程对象中, 需要调用QObject类提供的moveToThread()方法

  ```
   // void QObject::moveToThread(QThread *targetThread);
   // 如果给work指定了父对象，这个函数调用就失败了
   // 提示：QObject::moveToThread: Cannot move objects with a parent
   work->moveToThread(sub); // 移动到子线程中工作
  ```

   6.启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作
   7.调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的

#### 问题

##### 头文件寻找

- `/usr/include/qt5/`：这是Qt 5.x版本的头文件路径。

- `/usr/local/include/qt5/`：这是本地安装的Qt 5.x版本的头文件路径。

- `/usr/include/qt4/`：这是Qt 4.x版本的头文件路径。

- `/usr/local/include/qt4/`：这是本地安装的Qt 4.x版本的头文件路径。

  ```
  sudo find / -name "Qt5Core.h" 2>/dev/null
  ```

**->命令：**


```
g++ -I /home/wybie/dailywork/communicate/qt_new/include \
    /home/wybie/dailywork/communicate/qt_new/src/crc.cpp \
    /home/wybie/dailywork/communicate/qt_new/src/server.cpp \
    /home/wybie/dailywork/communicate/qt_new/src/uart.cpp \
    -o /home/wybie/dailywork/communicate/qt_new/.o/qt -lfmt
```

### Qt项目

- **qml与c++的交互：**

  QML 与 C++ 的交互主要有四种方式：注册 C++ 对象到 QML，在 QML 中访问 C++ 对象；QML 暴露对象给 C++ 进行交互；C++ 创建 QML 对象并进行交互；C++ 对象与 QML 通过信号槽进行交互->在我的简单应用中，用了第一种（object继承类声明给qml识别）及第四种（信号量与槽函数交互，分为手动绑定和自动绑定两种方式，主函数实例化通知到item和在页面id中connct函数传入参数）

- qml代码解析：

  虽然界面看着很复杂，其实内里逻辑确实就是bool，分为三个部分，ip号，端口号和连接状态，然后将输入的值应用，查看返回的连接状态，选择一个之后便广播一个通知，传入参数切换状态，然后也没有处理套接字等的逻辑，思考原因可能主要是在控制页面主要就是控制查看连接状态，进入摇杆ui后，才是真正的部分，将赋入的真实的套接字信息创建了，然后在用套接字进行数据的发送接收处理


- 解析tcpclient类：

  主要是管理线程和通信，状态设置查看，有配合数据包使用的状态信息，通信的错误码返回，和配合设备使用的连接，析构连接子对象；其对应的信号量和槽在头文件中声明

- 解析tcpwork类：

  主要是数据传输，通过多线程和队列向服务端写入数据，加入了多种线程保护机制和防止程序崩溃机制，比如多次验证队列不为空和套接活跃；将信号量和槽函数的绑定和解绑封装，以及写了返回错误状态码的逻辑。

- **信号和槽就是 Qt 的“事件机制”**：
  当一个对象中发生某个事件时（**发出信号**），其他对象可以自动收到通知（**执行槽函数**）。确定ui页面的id,在主函数中进行信号量和槽函数的绑定

  1. 手动绑定

     ```
          // ========== QML 信号连接到 C++ 槽函数 ==========
         if (!engine.rootObjects().isEmpty()) {
             QObject *root = engine.rootObjects().first();
             QObject *connectPage = root->findChild<QObject*>("pageTcp"); // QML 里 id: pageTcp
     
             if (connectPage) {
                 QObject::connect(connectPage, SIGNAL(connectToServer(QString,int)),
                                  &communicate, SLOT(connectToServer(QString,int)));
     
                 QObject::connect(connectPage, SIGNAL(disconnectFromServer()),
                                  &communicate, SLOT(disconnectFromServer()));
     }
     }
     ```

  2. 自动绑定

     ```
     //.hpp
     public:
        Q_INVOKABLE void connectToServer(QString ip, int port);
        Q_INVOKABLE void disconnectFromServer();
     
     //.qml
     Item {
         id: connectPage
     
         Button {
             text: "连接"
             onClicked: tcpClient.connectToServer(ipInput.text, portInput.text)
         }
     
         Button {
             text: "断开"
             onClicked: tcpClient.disconnectFromServer()
         }
     
         Connections {
             target: tcpClient
             onConnectionStateChanged: {
                 console.log("TCP 状态:", state)
             }
         }
     }
     ```

- 有一说一，感觉这个通信界面本质就是用前端把要填入端口号的text显示出来，ip地址同理

- 为了让 QML 能识别并使用你的 C++ 类，该类通常需要：继承自 **QObject**；使用 **Q_OBJECT** 宏；**signals** —— 定义信号，QML 可以接收；然后如果要在qml中使用信号量，则在主函数注册给它

  ```
  TcpClient tcpClient; // 创建一个实例
      engine.rootContext()->setContextProperty("tcpClient", &tcpClient);
  ```

- ```
  explicit TcpClient(QObject *parent = nullptr);
  ```

  **声明了一个名为 TcpClient 的类的构造函数，它接受一个可选的 QObject 指针参数 parent，默认值是 nullptr；并且这个构造函数被标记为 explicit，防止隐式类型转换。**

- 关于在qml中数据的发送

  - 什么是JavaScript?

    https://www.runoob.com/js/js-howto.html

- 套接字识别失败，是因为注册的对象是子类，实例化的是父类，子类无法直接使用；保留 `qmlRegisterType<Comms>` 可以让 QML 使用 `<Comms>` 标签创建新实例

- ```
  QString payload = QString("%.2f,%.2f").arg(x, y); 
  ```

  `QString::arg()` 不支持一次传多个参数用逗号分隔。正确写法是 链式调用 或者按顺序调用：

  注意中间是占位符，不能用.2f，因为Qt **不支持 `"%.2f"` 这种 C 风格格式** 来表示小数位

  ```
  QString payload = QString("%1,%2").arg(x, 0, 'f', 2).arg(y, 0, 'f', 2);
  ```

- 将 `payloadBytes`（`QByteArray`类型）转换为 `QString`;将 `calcCRC`（32 位无符号整数）格式化为 **8 位大写十六进制字符串**，都不能直接使用，会产生argument missing找不到参数问题。

  应提前转成 8 位十六进制字符串类型，在包中拼帧

- 构思一下：两个ui设想用一种包，下位机的逻辑是x线速度，y线速度，z角速度，可以在qt端直接发过来解决，省去一种包的解析，但是需要两种函数互传，因为麻烦的是在一个模块下关于角速度是未定义的；或者选择两种包在主机端拼帧，需要写两个解析逻辑是小事，但我的qt端全是明文载荷，往payload里面塞参数，粘包很严重

- **数据解析大法：**

  - **指针大法：**

    第一招：设立环状缓冲区接收，返回接收信息长度，>0就进入if开始找帧头帧尾，并返回bool,若true就开始数据发布，当缓冲区内存头尾相等了就清除，防止数据割裂

    第二招：数据处理时，初始化流转化float为double，用指针查找头后进入数据处理解析，到尾了就取出后面的八位字节转为校验码校验；下位机上更是写了三个char数组用于接收部分，数据部分，校验码部分，逻辑全用计算字节，if指针实现

  - **结构体大法：**

    发送端和接收端建立相同结构体，因为字节相同，memcpy进一段内存，发出后memcpy出来可以直接给成员赋值，然后就可以直接用，听着很心动，待测试->测试过了，暂时没什么问题

**10.28**

想给qt接收单独分一个线程出来，因为有时候分离线程对优化通信来说很有用，但在创建qt线程后没有进我的打印调试，线程没有初始化成功，排查了代码问题后，开始思考构造方式，qt线程的两种创建方式，继承thread类和添加线程，学长用的是继承写run的方式，但是因为我的套接字在qobject类里面，就想继承父类通过第二种方式写套件字的接收解析逻辑，最后发现是因为不符合qt规范，QObject 父子关系强制要求事件、销毁、回调在同一线程处理，让我感觉非常痛苦->发现学长读和写放在一个类，发出信号接收类作数据处理，并添加互斥锁和队列，接收或构建了数据包后上锁append队列，在套接字类中操作队列

**10.29**

qt通信大换血，改成套接字类和共享类，数据处理类的格式->现在共享类里面是公用的数据成员和信号成员，想要在其他的cpp里面调用，数据处理类append,套接字类连接和发送并传输qml信号但继承共享类后多线程就需要继承链了，摇来学长后，发现学长的实现逻辑是写一个注册的大类用于qml调用，然后再分主要管理底层信号的两个大类，然后在大类在分小的子类逻辑处理，继承共享类后定义指针构造引用实现类间调用，多线程的实现是在管理类中定义线程，然后在子类中书写逻辑构造中触发->思考了一下，定的逻辑是注册套娃类，qml触发套接字父类共享信号，父类作为信号接收调用子类函数

### TCP粘包处理

1. 读到包头包尾后**得到包的长度**，从而取出数据块。
2. 长连接中的**心跳包**，**保活**和**防死链**，即在网络突然断开连接后通过心跳包发现离线状态。  

### 卡尔曼滤波

<img src="https://i-blog.csdnimg.cn/blog_migrate/63235ce47d9e92d66b5630eb9f34add5.png" alt="img" style="zoom:67%;" />

#### 线性卡尔曼

基本滤波：https://blog.csdn.net/navsense_support/article/details/146210928

卡尔曼滤波：https://blog.csdn.net/navsense_support/article/details/146231513

（线性）卡尔曼滤波的应用基于以下三个假设前提：

1. 当前时刻状态只和**上一时刻**状态有关。
2. 模型和系统均满足**线性**关系。
3. 引入的噪声符合**高斯**分布。

**矩阵 H的作用**：**只让测量到的部分进行修正**，不会影响其他状态变量。

修正方程：

<img src="主机.assets/image-20251023193221379.png" alt="image-20251023193221379" style="zoom:50%;" />

衡量两个随机变量 **X** 和 **Y** 之间共同变化趋势的度量,样本协方差的公式为：

![image-20251023174218212](主机.assets/image-20251023174218212.png)

（先验）测量误差：

<img src="主机.assets/image-20251023211547021.png" alt="image-20251023211547021" style="zoom: 67%;" />

这个是在运动过程中传感器自身产生的过程噪声，B为控制量矩阵，uk为控制量，wk为过程噪声

（后验）卡尔曼增益计算：        

<img src="主机.assets/image-20251023175604327.png" alt="image-20251023175604327" style="zoom:50%;" />

HHH：把状态（如位置、速度）投影到测量空间（如传感器的输出：只测位置）；

HTH^THT：则是“反向传播”测量误差信息到状态空间。

HPk−HT->状态预测误差映射到测量空间后的协方差

**线性卡尔曼总结**：传感器有自身的噪声和坏掉的概率等产生的误差，除了测量值产生的过程误差，同时计算出的预测值也有可能因为显示因素产生误差，在引入噪声符合高斯分布时，可以通过协方差计算得出Pk作为预测误差，R作为传感器本身的噪声误差，由厂家给出，但因为实际中有光线角度等因素，所以还需要调整；测量误差同理，将控制量乘矩阵变化为状态空间，同时因为预测误差在状态空间不一定能用的上，所以用H的变换矩阵将测量空间的误差转换为状态空间内的，再乘HT将状态空间内计算的误差进行修正还原到T时刻的ui测量空间，完整公式是预测值加上增益量乘上测量值减去预测值，增益量可视作预测量的置信度，增益量的计算是状态误差在总误差中的占比

**调参**：

| 理论                                  | 实践                                   |
| ------------------------------------- | -------------------------------------- |
| 厂家可以提供 R 的初始估计（噪声方差） | 实际使用中必须根据实测和运行效果调整 R |

这里适用的情况就是机器人运动轨迹为线性，但在实际中并不常见

#### 实现：

https://zhuanlan.zhihu.com/p/712472138



#### 扩展卡尔曼

https://blog.csdn.net/qq_41204464/article/details/123874233

非常好文章：https://blog.csdn.net/O_MMMM_O/article/details/106078679

非常非常好文章：https://blog.csdn.net/AdamShan/article/details/78265754

泰勒公式是一个用函数在某点的信息描述其附近取值的公式,在**均值处进行一阶泰勒展开**,从而逼近平滑函数

<img src="https://i-blog.csdnimg.cn/blog_migrate/a8ef29cba24440cf4b3ae0be078a1d61.png" alt="img" style="zoom: 67%;" />

其中<img src="https://i-blog.csdnimg.cn/blog_migrate/d0f2a0e575e42cce9eb038434e277187.png" alt="img" style="zoom:50%;" />是展开后得到的一阶偏导项        

**雅可比行列式**：**多变量函数的一阶偏导构成的矩阵**，用于描述输入变化对输出的线性影响，比如坐标变换中，从直角坐标 (*x*,*y*)变换到极坐标 (*r*,*θ*)时，面积微元要从 *d**x**d**y*变为 *r**d**r**d**θ*，即将矩形微元扭曲为弧长乘半径

<img src="主机.assets/image-20251025143658608.png" alt="image-20251025143658608" style="zoom:50%;" />                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

计算过程就是，控制输入对于运动模型的每一行求偏导，然后写成一行，依次写三行，就能将非线性系统化成线性，得出雅克比矩阵

<img src="https://i-blog.csdnimg.cn/blog_migrate/0f2db6b62d23dd7d99a6978cc6734edc.png" alt="这里写图片描述" style="zoom:50%;" />

# 开发相关 

## ==开发工具链==

### 1. **编译工具链  **

编译工具链是将源代码转换为嵌入式系统可以执行的机器码的核心部分。嵌入式系统通常有不同的硬件架构（如 ARM、MIPS、x86 等），因此需要使用特定的交叉编译器。

#### ==g++==

- 切换编译器版本

```
sudo update-alternatives --config g++
g++ --version
```

**-o**：指定输出文件的名称。例如：

```
g++ -o program main.cpp
```

**-c**：只编译源代码，不进行链接，生成对象文件。例如：

```
g++ -c main.cpp
```

**-I**：指定头文件的搜索路径。例如：

```
g++ -I /path/to/headers main.cpp
```

**-L**：指定库文件的搜索路径。例如：

```
g++ -L /path/to/libs main.cpp -lmylib
```

**-l**：链接指定的库。例如：

```
g++ main.cpp -lmylib
```

**-g**：生成调试信息，用于调试器（如 gdb）。例如：

```
g++ -g main.cpp
```

**-std=**：指定使用的 C++ 标准。例如：

```
g++ -std=c++11 main.cpp
```

**-Wall**：启用所有警告信息。例如：

```
g++ -Wall main.cpp
```

**-shared**：生成动态链接库。例如：

```
g++ -shared -o libmylib.so mylib.cpp
```

**示例：**

```
wybie@wenjun:~/communicate/qt$ g++ -I /home/wybie/communicate/qt/include \
    /home/wybie/communicate/qt/src/receive.cpp \
    /home/wybie/communicate/qt/src/uart.cpp \
    /home/wybie/communicate/qt/src/crc.cpp \
    -o /home/wybie/communicate/qt/.o/qt
```

**1.1** **交叉编译器（Cross Compiler）**

交叉编译器是用于在一个平台（如 x86 架构的计算机）上编译目标平台（如 ARM、MIPS 等架构）的代码。常见的交叉编译器包括：

- **GCC（GNU Compiler Collection）**：支持多种架构，广泛应用于嵌入式开发中。例如，`arm-none-eabi-gcc` 用于 ARM 系列处理器。
- **Clang/LLVM**：是一款现代化的编译器，支持多种平台和编程语言，也适用于嵌入式开发。
- **Keil MDK**：专门针对 ARM Cortex-M 系列微控制器开发的 IDE，内含交叉编译器。

部署：

写一个简单的.c文件->编译命令：`${CROSS_COMPILE}gcc main.c -o main_arm`->远程复制：`scp main_arm user@target_ip:/home/user/`->目标系统上运行:`chmod +x main_arm
./main_arm`

**1.2** **工具链的组成**

一个完整的交叉编译工具链通常包括：

- **编译器**：如 `gcc`、`clang`，用于将源代码编译为目标平台可执行的二进制代码。
- **链接器**：如 `ld`，负责将目标文件链接成可执行文件，并解析库依赖。
- **汇编器**：如 `as`，用于将汇编语言转化为机器码。
- **调试器**：如 `gdb`，用于调试嵌入式系统中的程序，支持远程调试。

**1.3** **工具链管理**

- **Buildroot**：一个用于构建嵌入式 Linux 系统的工具，可以自动下载、构建和安装交叉编译工具链。
- **Yocto Project**：一个强大的开源工具，能够创建定制化的嵌入式 Linux 发行版，也包括构建交叉编译工具链。
- **CMake**：一个跨平台的构建系统，支持多种编译器和工具链配置。

#### **CMAKELISTS.TXT**格式 

```
cmake_minimum_required(VERSION 3.8)
project(odom_imu_pkg)

# ---------------------
# 编译标准
# ---------------------
if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

# ---------------------
# 查找依赖包
# ---------------------
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(nav_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(tf2_ros REQUIRED)

# ---------------------
# 源文件（可以有多个）
# ---------------------
set(SOURCES
  src/odom_imu_publisher.cpp
)

# ---------------------
# 可执行文件
# ---------------------
add_executable(odom_imu_publisher ${SOURCES})

# ---------------------
# 链接依赖
# ---------------------
ament_target_dependencies(odom_imu_publisher
  rclcpp
  nav_msgs
  sensor_msgs
  geometry_msgs
  tf2_ros
)

# ---------------------
# 安装目标
# ---------------------
install(TARGETS
  odom_imu_publisher
  DESTINATION lib/${PROJECT_NAME}
)

# ---------------------
# 安装头文件（如果有 include/）
# ---------------------
install(DIRECTORY include/
  DESTINATION include/
)

# ---------------------
# 导出 package
# ---------------------
ament_package()
```

### 2. 交叉编译链

https://blog.csdn.net/u012503639/article/details/104159375

### 3. **调试工具**

调试是嵌入式开发中非常重要的一个环节，涉及从系统级调试到代码级调试。常见的调试工具有：

**3.2** ==**GDB（GNU 调试器）**== **--->>这个很好用**

GDB 是一个强大的调试工具，支持多种架构，适用于 Linux 下的嵌入式系统。它支持断点调试、单步执行、变量监视等功能。

- **OpenOCD**：与 GDB 一起使用的开源工具，能够通过 JTAG/SWD 连接嵌入式设备，进行调试。

  | 命令                             | 说明                  |
  | :------------------------------- | :-------------------- |
  | `gdb <可执行文件>`               | 启动 GDB 调试指定程序 |
  | `gdb --args <可执行文件> <参数>` | 带参数启动程序        |
  | `run`或 `r`                      | 运行程序              |
  | `quit`或 `q`                     | 退出 GDB              |

```
ls install/<package>/lib/<package>/
ros2 pkg executables
//查看错误栈
bt
gdb + 执行文件
run + 命令
```

### 4. **版本控制与协作工具**

版本控制系统在嵌入式开发中尤为重要，它有助于团队协作、代码管理和回溯历史。

**5.1** **Git**

Git 是最常用的分布式版本控制系统，可以通过 GitHub、GitLab 或 Bitbucket 进行代码托管。Git 可以方便地进行版本管理、分支管理和协作开发。

## ==上位机操作==

### ssh密钥连接：

1. 本地生成`ssh-keygen -t rsa -b 4096 -C "wybie@example.com"`
2. 复制公钥`cat ~/.ssh/id_rsa.pub`
3. 登陆从机`ssh-copy-id username@server_ip`
4. 远程登陆`ssh username@server_ip`
5. 文件传输`scp -r /home/titr_2/Desktop/wwj wybie@192.168.4.29:/home/wybie/`

### 开机自启：

1. 查询服务`systemctl list-units --type=service | grep getty`

2. 自动网络连接

   ```
   [Unit]
   Description=Bring up WiFi connection titr
   After=network-online.target
   Wants=network-online.target
   
   [Service]
   ExecStart=/usr/bin/nmcli connection up titr_pq_1
   ExecStop=/usr/bin/nmcli connection down titr_pq_1
   RemainAfterExit=true
   Type=oneshot
   ExecStartPost=/bin/sleep 5
   
   [Install]
   WantedBy=multi-user.target开机自启服务
   ```

3. 脚本文件编写

   ```
   titr_2@titr:~/StartUP$ sudo cat startup_usb.sh
   #!/bin/bash
   
   sleep 5
   
   
           gnome-terminal -- bash -c "
               cd /home/titr_2/pq/yolov5-usb-pq/build;
               ./yolov5_det ../pq-10000.engine s;
               echo 'Program exited. Restarting in 1 seconds...';
               exec bash
           "
   ```

   在脚本中命令行记得source ros2环境`source /opt/ros/humble/setup.bash`

4. **桌面快捷方式创建**

   ```
   [Desktop Entry]
   Type=Application
   Name= wwj_joystick
   GenericName= name
   Comment=test
   Exec=gnome-terminal -- bash -c "/home/titr_2/StartUP/wwj_joy.sh; exec bash"
   Icon=utilities-terminal
   Terminal=true
   Categories=Utility;
   ```

   在 Linux（尤其是 GNOME 桌面环境）中，~/.config/autostart/ 目录下的 .desktop 文件是 用户级开机自启动项 的标准配置方式，所以当桌面文件配置时若在这个目录下就会开机自启

### 静态ip设置：

```
sudo nano /etc/netplan/01-network-manager-all.yaml
```

```
network:
  version: 2
  renderer: NetworkManager
  wifis:
    wlo1:
      dhcp4: false
      addresses: [192.168.198.1/24]
      access-points:
        "wwj":
          password: "linux520"
```

`nm-connection-editor`里自己改最好用，因为yaml文件格式要求严格

`sudo netplan try`  `sudo netplan apply`

### 服务编写

```
 wybie@wenjun:~$ systemctl cat hotspot.service
# /etc/systemd/system/hotspot.service
[Unit]
  Description=Hotspot.Service
  After=network-online.target
  Wants=network-online.target

[Service]
  ExecStart=/usr/bin/nmcli connection up id wwj
  ExecStop=/usr/bin/nmcli connection down id wwj
  RemainAfterExit=yes

[Install]
  WantedBy=multi-user.target
```

`systemctl enable/disable hotstpot.service`开机自启和关闭

### jetson驱动can

之前的记录被刷掉了，根据学长的命令下好了pcan也挂载上了，到nvidia官网找了运行命令并让ai写了脚本

https://docs.nvidia.com/jetson/archives/r35.2.1/DeveloperGuide/text/HR/ControllerAreaNetworkCan.html

- 有时候出现buffer is full的问题：https://blog.csdn.net/wteruiycbqqvwt/article/details/128234807?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167651800216800182716497%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167651800216800182716497&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128234807-null-null.142%5Ev73%5Econtrol_1,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&utm_term=%20write%3A%20No%20buffer%20space%20available&spm=1018.2226.3001.4187

- ```
  ip -s link show can0
  ip -details link show can0
  ```

- **USB-TO-CAN:**

  https://www.jianshu.com/p/75db013fa3b7

- **ROS里跑can：**

  https://blog.csdn.net/qq_38880380/article/details/131028462

- **周立功分析仪使用：**

  https://blog.csdn.net/bengkui2015/article/details/109672990

  ```
  //安装rust
  sudo apt update
  sudo apt install -y curl
  curl https://sh.rustup.rs -sSf | sh
  source $HOME/.cargo/env
  //虚拟环境启动
  cd ~/zlgcan/zlgcan-driver-rust-dev
  python3 -m venv .venv
  source .venv/bin/activate
  //编译
  pip install maturin
  maturin develop
  //验证
  python3
  >>> import zlgcan_driver
  >>> dir(zlgcan_driver)
  //2.0.6版本
  ```

  到zlgcan.py里面改path为下的头文件，但是队里的设备始终识别不到，一找2e的好像没有linux的驱动

  <img src="主机.assets/image-20251108115433189.png" alt="image-20251108115433189" style="zoom: 50%;" />

  并不支持linux

  

### 进程重启脚本

**后台启动：**

```
sudo vim /etc/systemd/system/名称.service
```

```
[Unit]
Description=Restart Service
After=network-online.target

[Service]
Type=simple
User=nvidia
WorkingDirectory=/home/nvidia
Environment=HOME=/home/nvidia
ExecStart=/bin/echo "test service OK"
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target
```

```
sudo systemctl daemon-reload
sudo systemctl restart restart.service
sudo systemctl status restart.service
```

**自动弹出终端：**

```
#!/bin/bash

while true;do
 if ! pgrep -f '/home/nvidia/wang/qt_new/.o/qt' > /dev/null; then
echo "shit!"
while [ ! -e /dev/ttyUSB_A ] || [ ! -e /dev/ttyUSB_B ]; do
    echo 'wait for the usart ...'
    sleep 1
    done
	gnome-terminal -- bash -c " 
	/home/nvidia/wang/qt_new/.o/qt
	"
 fi
 # echo "FUCK!"

    done
```

```
[Unit]
Description=Restart Service
After=graphical.target

[Service]
Type=simple
User=nvidia
Environment=HOME=/home/nvidia 
Environment=DISPLAY=:0
Environment=XAUTHORITY=/home/nvidia/.Xauthority
WorkingDirectory=/home/nvidia/wang/useful
ExecStart=/bin/bash /home/nvidia/wang/useful/qt.sh
Restart=Always
RestartSec=3

[Install]
WantedBy=graphical.target
```

```
journalctl -u restart.service -e
```

如果程序返回非 0 退出码才重启；

```
#include <cstdlib>
std::exit(EXIT_FAILURE);
```



### 热点频段更改

```
sudo nmcli dev wifi hotspot ifname wlP1p1s0 ssid titr_dog_1 password "titr2025" band a channel 165
```

解释：

band a → 表示使用 5 GHz；band bg → 表示使用 2.4 GHz；channel表示信道

### 桌面自启脚本

```
[Desktop Entry]
Type=Application
Exec=/home/nvidia/StartUP/start_1.sh
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name[en_US]=/home/nvidia/StartUP/start_1.sh
Name=/home/nvidia/StartUP/start_1.sh
Comment[en_US]=
Comment=
Hidden=
```

### git使用

```
//在主页上看自己的密钥，记得一定要给密钥开权限，具体问ai
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
//根据命令走完一遍后，用下面的
git remote set-url origin https://github.com/wybie450/c-.git
git push -u origin main --force
```

### orin nx扳机刷机

```
$ tar xf ${L4T_RELEASE_PACKAGE}
$ sudo tar xpf ${SAMPLE_FS_PACKAGE} -C Linux_for_Tegra/rootfs/
$ cd Linux_for_Tegra/
$ sudo ./tools/l4t_flash_prerequisites.sh
$ sudo ./apply_binaries.sh
$ sudo ./tools/kernel_flash/l4t_initrd_flash.sh --external-device nvme0n1p1 \
  -c tools/kernel_flash/flash_l4t_t234_nvme.xml -p "-c bootloader/generic/cfg/flash_t234_qspi.xml" \
  --showlogs --network usb0 jetson-orin-nano-devkit internal
```

图为在扳机刷机前需要设备树更改：

```
sudo vim /home/wybie/expand_blk/jetson/36.3/Linux_for_Tegra/bootloader/tegra234-mb2-bct-misc-p3767-0000.dts
cvb_eeprom_read_size = <0x100>; -> 0x0
```

## ==问题==

如果路由器启用了 **“WPA3-Personal”** 或 **“WPA2/WPA3 混合模式”**：

- 某些无线网卡驱动（特别是老款 Intel、Broadcom、Realtek）
  或 Jetson 的 `wpa_supplicant` 版本 **不支持 WPA3 SAE**；
- 结果表现就是：
  **“信号满格、密码正确，但始终无法连接”** ——
  就像你现在的情况。

### **静态ip导致网卡没了：**

1.dhc获取ip地址缓存清除
2.dhc重新获取ip地址
3.查看网络状态（`sudo nmcli status`）
4.修改NetworkManager配置为true
5.修改`/usr/lib/NetworkManager/conf.d`路径下10开头的文件，最后除去其他网络类型
6.重启网络管理器
7.apt更新
8.重启
猜测原因：设定静态ip后，可能产生ip冲突，需要通过dhc重分配
netplan apply出错
yaml有严苛的格式要求如下图

![yaml格式要求 的图像结果](data:image/jpeg;base64,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)

**热点开启不用hostapd，其与程序冲突**
.desktop文件在`~/.local/share/applications`中创建，再移到桌面

### **串口未识别到ch340：**

方法1：
1.根据csdn教程根据获取的版本号下载对应ch34*驱动
2.下载好用make编译，并将生成的.ko文件复制到系统默认内核驱动文件
3.用`dmesg | grep ttyUSB`*检查是否检测到
方法2：
1.用`dmesg | grep brltty`检查是否和系统默认驱动产生冲突
2.若显示interface 0 claimed,则apt移除
串口映射路径是device*而不是串口设备名

### vnc服务无法正常启动：

输入vncserver -list查看错误原因
端口被占用：1.`ps -ef | grep tightvnc`查找进程号 `sudo kill -9 <进程ID>`
2.用rm删除占用文件

### 系统自带vino软件：

1.下载gnome桌面环境
2.按csdn教程配置vnc服务
3.打开按照旧版协议运行
✖`sudo netstat -tlnp`查找端口号
gateway4过老已弃用,gaiyong routes
`sudo apt install -f`下载依赖修复命令
`sudo dpkg -i`解压deb安装包

### 磁盘扩容：

1.下载gparted图形化工具
2.插入安装盘进入试用模式
3.在使用模式中`sudo gparted`进入磁盘分区N
4.通过将未分配空间移动到p9和p10间进行扩容
5.勾选绿色保存，扩容完成
注意：进入使用模式前按e通过`nomedeset`关闭显卡驱动，不然会黑屏
**什么是cuda和cudnn？**
cuda是使用显卡GPU计算能力的编程系统，cudnn是实现操作的程序库
CUDA vs CUDN
    CUDA 是通用并行计算平台，适用于多种高性能计算任务。
    cuDNN 是深度学习专用库，基于CUDA，提供高效深度学习操作实现。
 ！`sudo chmod -R`表更改文件夹下所有文件权限
打开软件与更新，携带装的驱动改用535专用驱动（如果用的NVIDIA显卡）

### 网卡无法识别

1. 内核升级；在windows网卡硬件中查看设备类型，如wifi7网卡需要的内核在6.11以上

2. 设备查找；到厂家官方询问是否是硬件设备不允许在ubuntu下运行

3. 网卡驱动；rtl8824常见问题，内核中没有相应驱动，到github查找官方开源驱动，mkdir文件夹，克隆编译，cmake install安装，生成.ko文件，用mdprobe挂载驱动，可能会出现firmware固件报错，查找命令禁用原驱动索引到当前驱动下

   ->蓝牙同理，rtl8922的网卡可以识别后还需要为蓝牙框架wget一个网站后挂载固件驱动

最后发现问题，是mainline找的内核与默认环境下Ubuntu22.04的依赖环境不兼容导致无法识别头文件，要在默认环境下编译后修复固件并重新挂载，再升级内核即可找到

```
git clone https://github.com/lwfinger/rtw89.git
cd ~/driver/rtw89-main
make clean
make -j$(nproc)
sudo make install
sudo depmod -a
sudo modprobe -r rtw_8851b rtw89pci rtw89core rtw_8922ae  # 清理现有模块
sudo modprobe cfg80211 mac80211                           # 加载基础依赖
sudo modprobe rtw89core                                   # 先加载核心模块
sudo modprobe rtw89pci                                    # 再加载 PCI 驱动
sudo modprobe rtw_8922ae                                  # 最后加载网卡驱动
# 创建固件目录（如果不存在）

sudo mkdir -p /lib/firmware/rtw89
# 下载固件（从官方内核仓库）

sudo wget -O /lib/firmware/rtw89/rtw8922a_fw.bin https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/rtw89/rtw8922a_fw.bin
# 设置权限

sudo chmod 644 /lib/firmware/rtw89/rtw8922a_fw.bin
# 重新加载驱动

sudo modprobe -r rtw_8922ae && sudo modprobe rtw_8922ae
# 检查驱动是否加载

lsmod | grep rtw89
# 检查网卡是否绑定驱动

lspci -nnk | grep 8922 -A 3
```

->第二次遇见问题

内核拓展包安装：

```
sudo apt update
sudo apt install linux-modules-extra-6.8.0-83-generic
```

如果你有 NVIDIA 驱动、VirtualBox、ZFS 之类依赖 DKMS 的东西，最好也装上 **headers** 包：

```
sudo apt install linux-headers-6.8.0-83-generic
```

->图为t801

官方镜像文件里没有对应的8852.ko文件，需要找图为官方要36.3的刷机手册，配合他们自己的setup和roofs刷进去

### ttyACM0设备

**cdc_acm** 驱动下的

与ttyUSB的区别：https://zhuanlan.zhihu.com/p/392491394

串口中自己发送的只能由自己读回

短接发送接收，用以下命令检查，在终端输入回车看灯闪不闪

```
cat /dev/ttyACM0 & cat > /dev/ttyACM0
```

->之前可以正常通信，但不进串口，我把发送线程的锁关了，加了break,但是就是卡在接收线程出不来

因为串口忘了开非阻塞模式，而且创建线程的顺序错误

### jetson显驱

查询命令不是`nvidia-smi`(平台默认没有这个命令)

很重要的一点，不要用.run也不要后端apt nvidia官方驱动，jetson的显驱和cuda,tensorrt都是刷机时在jetpack中一体的，前者都是x86架构，arm架构下这些都是自带的，可以用命令进行gpu测试

```
tegrastats
```

```
/usr/local/cuda/bin/nvcc --version
```

```
dpkg -l | grep tensorrt
```

**不小心下载官驱搞乱环境**

```
sudo apt --fix-broken install
sudo apt purge 'nvidia-*'
sudo apt autoremove
sudo dpkg --remove --force-depends libnvidia-decode-535 nvidia-compute-utils-535 nvidia-driver-535 libnvidia-gl-535 libnvidia-compute-535 libnvidia-extra-535 nvidia-utils-535
sudo apt --fix-broken install -y
sudo apt autoremove -y
sudo apt clean
dpkg -l | grep nvidia//检查只有arm架构的
sudo dpkg --remove --force-depends \
    libnvidia-cfg1-535 \
    libnvidia-common-535 \
    libnvidia-fbc1-535 \
    nvidia-compute-utils-535 \
    nvidia-dkms-535 \
    nvidia-firmware-535-535.230.02 \
    nvidia-kernel-common-535 \
    nvidia-kernel-source-535 \
    xserver-xorg-video-nvidia-535
sudo apt clean
sudo rm -f /var/cache/apt/archives/*nvidia-535*.deb
sudo apt --fix-broken install -y
sudo apt autoremove -y
```

**遇到内核编译进程占据apt**

通过这些命令可视化

```
top -n 1 | grep -E "cc|gcc"
ps -o pid,ppid,cmd,%cpu,%mem -C gcc
watch -n 5 'ps -o pid,cmd,%cpu,%mem -C cc1'
```

### 开机自启

```
journalctl -b | grep -i hotspot
journalctl -b | grep -i nmcli

Hidden=false
X-GNOME-Autostart-enabled=false

ls /etc/xdg/autostart
```

```
nvidia@tegra-ubuntu:~$ nmcli -g connection.autoconnect connection show titr_dog_1
no
ls /etc/NetworkManager/dispatcher.d/
ls /etc/NetworkManager/system-connections/
```

```
nvidia@tegra-ubuntu:/etc/NetworkManager/system-connections$ grep -Ri "titr_dog_1" /etc/systemd/system
grep: /etc/systemd/system/multi-user.target.wants/snapd.aa-prompt-listener.service: No such file or directory
/etc/systemd/system/multi-user.target.wants/hotspot.service:ExecStart=/usr/bin/nmcli connection up titr_dog_1
/etc/systemd/system/multi-user.target.wants/hotspot.service:ExecStop=/usr/bin/nmcli connection down titr_dog_1
/etc/systemd/system/hotspot.service:ExecStart=/usr/bin/nmcli connection up titr_dog_1
/etc/systemd/system/hotspot.service:ExecStop=/usr/bin/nmcli connection down titr_dog_
```

### 无法识别conda

```
sudo vim ~/.bashrc

export PATH=/usr/local/cuda/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda/lib64:/opt/TensorRT-8.6.1.6/lib:$LD_LIBRARY_PATH
export CUDA_HOME=/usr/local/cuda

source install/setup.bash
```

### **jetson ros2环境**

确保 Jetson Nano 已安装 **Ubuntu 20.04** 或 **22.04** 系统。

确保网络连接稳定，并更新系统：

```
sudo apt update && sudo apt upgrade -y
```

步骤 1：安装依赖项

安装必要的软件包：

```
sudo apt install -y curl gnupg2 lsb-release
```

步骤 2：添加 ROS2 软件源

添加 ROS2 公钥：

```
sudo curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -
```

添加 ROS2 软件源：

```
sudo sh -c 'echo "deb [arch=$(dpkg --print-architecture)] http://packages.ros.org/ros2/ubuntu $(lsb_release -cs) main" > /etc/apt/sources.list.d/ros2-latest.list'
```

更新软件源：

```
sudo apt update
```

步骤 3：安装 ROS2

以安装 ROS2 Humble 为例（适用于 Ubuntu 22.04）：

```
sudo apt install -y ros-humble-desktop
```

对于 Ubuntu 20.04，可安装 Foxy 版本：

```
sudo apt install -y ros-foxy-desktop
```

步骤 4：配置环境变量

将 ROS2 环境变量添加到 *.bashrc* 文件中：

```
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc

source ~/.bashrc
```

如果使用 Foxy，请将 *humble* 替换为 *foxy*。

步骤 5：测试安装

打开一个终端，运行发布者节点：

```
ros2 run demo_nodes_cpp talker
```

打开另一个终端，运行订阅者节点：

```
ros2 run demo_nodes_py listener
```

若能看到消息正常传递，则说明安装成功。

优化建议

**内存管理**：Jetson Nano 内存有限，建议增加交换空间：

```
sudo fallocate -l 4G /var/swapfile

sudo chmod 600 /var/swapfile

sudo mkswap /var/swapfile

sudo swapon /var/swapfile

echo "/var/swapfile swap swap defaults 0 0" | sudo tee -a /etc/fstab
```

**CUDA 支持**：确保 CUDA 环境已正确配置，以提升性能。

### jetson视觉环境恢复

```
//环境恢复
sudo apt update
sudo apt install nvidia-jetpack -y
```

梳理思路：

现在是用dpkg在环境下都有cuda相关的包，但是没有创建符号链接，并且在相关全局查找下也没有一样的包，，按理来说，下载好后，创建符号链接，然后就可以Import检查，我感觉是这个系统不完整

```
sdkmanager --query //查看版本
```

降级了也没鸟用

**Jetson 为啥会从 NVMe 启动？**

1. **UEFI 默认行为**
   从 JetPack 5.x 开始，NVIDIA 改成了 UEFI 引导。
   UEFI 的逻辑是：
   - 先找有没有可启动的 NVMe/SSD
   - 如果有，就优先从 NVMe 启动
   - 如果没有，再从 eMMC / SD 启动



**`sudo ./tools/kernel_flash/l4t_initrd_flash.sh`**
 运行 NVIDIA 的 initrd flash 脚本，这是 Jetson Orin/Xavier 平台新的刷机方式（替代老的 `flash.sh`）。

**`--external-device nvme0n1p1`**
 指定 rootfs（系统盘）安装到的外部设备，这里是 NVMe SSD 的分区 `/dev/nvme0n1p1`。

**`-c tools/kernel_flash/flash_l4t_external.xml`**
 指定分区布局配置文件（external rootfs 的布局定义）。

**`-p "-c bootloader/t186ref/cfg/flash_l4t_t194_qspi_p3668.xml"`**
 这里的 `-p` 是传递给底层 `flash.sh` 的参数，
 它再指定了 **QSPI (SPI flash)** 的分区配置文件（用于保存 bootloader）。

**`--showlogs`**
 显示刷机过程中的日志（方便调试）。

**`--network usb0`**
 指定和 Jetson 通信的网络接口是 `usb0`（常见于 USB Recovery 模式的 RNDIS/ECM 网络）。

**`jetson-xavier-nx-devkit`**
 设备型号（你刷的是 Xavier NX 开发套件）。

**`internal`**
 表示刷写目标是 Jetson 的内部存储（eMMC/QSPI）——再结合 `--external-device`，意思是 **bootloader 在内部存储，rootfs 在外部 NVMe**。



在 Jetson 上编译 `torchaudio` 时，建议加上这两个环境变量，避免某些 CUDA 头文件找不到：

```
export TORCH_CUDA_ARCH_LIST="7.2"
export CMAKE_PREFIX_PATH=$(python3 -c 'import torch; print(torch.utils.cmake_prefix_path)')
```





- **jetson下载dk驱动**

添加软件源公钥：

```
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE || sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE
bash
```

添加软件源：

```
sudo add-apt-repository "deb https://librealsense.intel.com/Debian/apt-repo $(lsb_release -cs) main" -u
```

bash
安装 SDK：

```
sudo apt-get install librealsense2-utils
sudo apt-get install librealsense2-dev
```

bash
验证安装：

```
realsense-viewer
```



### 磁盘损坏

```
sudo parted /dev/sdb print //看分区表
sudo file -s /dev/sdb //输出data整盘损坏

//不保留数据
sudo parted /dev/sdc --script mklabel gpt
sudo parted /dev/sdc --script mkpart primary 0% 100%
sudo parted /dev/sdc print
sudo mkfs.ntfs -f /dev/sdc1 //尝试创建分区ntfs
sudo mkdir -p /mnt/sdc //挂载测试
sudo mount /dev/sdc1 /mnt/sdc
df -h | grep sdc
sudo umount /mnt/sdc
```

![image-20251013165431721](主机.assets/image-20251013165431721.png)



### linux卡顿

```
//cpu占比最多的
htop
//io资源消耗
iostat -x 1
```

### 识别不了exFat的u盘

```
sudo apt update
sudo apt install exfat-fuse exfatprogs -y
```

煤球用

```
sudo unmount 挂载点
sudo mkfs.vfat -F 32 /dev/sda1  //格式化为fat32
```

### 固定串口描述符

**主要规则文件路径**：

```
# 系统级规则（优先级最高）
/usr/lib/udev/rules.d/

# 本地管理员规则（推荐使用）
/etc/udev/rules.d/

# 临时规则（重启后失效）
/run/udev/rules.d/
```

**常用规则文件**：

```
# 查看现有串口规则
ls /etc/udev/rules.d/*.rules
ls /usr/lib/udev/rules.d/*serial* *.rules
```

```
# 更通用的规则（匹配所有FTDI芯片的USB转串口）
SUBSYSTEM=="tty", ATTRS{idVendor}=="0403", MODE="0666", GROUP="dialout", SYMLINK+="ttyUSBA"

# 针对特定设备的更精确规则
SUBSYSTEM=="tty", KERNELS=="3-2:1.0", MODE="0666", GROUP="dialout", SYMLINK+="ttyUnitree"
```

```
# 查看内核消息（实时监控）
sudo dmesg -w

# 查看最近的USB设备插入信息
dmesg | grep -i usb

# 查看串口设备注册信息
dmesg | grep -i tty
dmesg | grep -i "tty" | tail -10

# 查看特定时间后的消息（插入设备后运行）
dmesg --since="1 minute ago" | grep -i usb
```

### 设备树

https://zhuanlan.zhihu.com/p/665624816扳机刷完机之后连接otg识别不到device模式

配置了从机模式和ip link add ip地址给dev usb0，现象是主机能识别到虚拟网卡但ping不通，发现主机没有g_ether等相关驱动，可能链路层通了但网络层并未执行udc,解决方式是刷机重编译内核

```
echo device | sudo tee /sys/class/usb_role/usb2-0-role-switch/role
ls /sys/class/udc
cd /sys/kernel/config/usb_gadget/g1
echo 3550000.usb > UDC

```

修建设备树参考：https://www.cnblogs.com/SkyXZ/p/18572123

## ==常用命令==

```
//查询Ubuntu版本号
lsb_release -a
//查询jetpack信息
dpkg -l | grep nvidia-l4t-core

sudo apt update
sudo apt install jetpack-info
jetpack-info
//查询jetpack版本
cat /etc/nv_tegra_release
//查询系统架构
arch
//查询网络接口类型
nmcli device status
//查询频段
iw dev 网卡名称 info
sudo nmcli dev wifi list
iw list
find 文件系统 -name "文件名" 2>/dev/null
```

if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi
export PATH=/usr/local/cuda-12.2/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda-12.2/lib64:$LD_LIBRARY_PATH
